<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference (API) · SurvivalAnalysis</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SurvivalAnalysis</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><a class="tocitem" href="../howto/">How-to guides</a></li><li><a class="tocitem" href="../explanations/">Explanations</a></li><li class="is-active"><a class="tocitem" href>Reference (API)</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li></ul></li><li><a class="tocitem" href="../news/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference (API)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference (API)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.ConcordanceWeights" href="#SurvivalAnalysis.ConcordanceWeights"><code>SurvivalAnalysis.ConcordanceWeights</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConcordanceWeights(S::Int8, G::Int8, tied_preds::Float64 tied_times::Float64)</code></pre><p>Weights used in the <a href="#SurvivalAnalysis.concordance"><code>concordance</code></a> function. <code>S</code> and <code>G</code> reflect the power applied to the Kaplan-Meier estimates of the survival and censoring distributions of the fitted data used to apply weighting at a given time. For example <code>ConcordanceWeights(1, -2, 0.5, 0.5)</code> will tell the <code>concordance</code> function to multiply concordant pairs at time <code>t</code> by <code>S(t)/G(t)²</code>. <code>tied_preds</code> and <code>tied_times</code> determine how to handle ties in predictions and observed times respectively.</p><p>See <a href="#SurvivalAnalysis.concordance"><code>concordance</code></a> for full examples.</p><p>Note❗It is strongly recommended that <code>S ≥ 0</code> and <code>G ≤ 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/concordance.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.KaplanMeier" href="#SurvivalAnalysis.KaplanMeier"><code>SurvivalAnalysis.KaplanMeier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KaplanMeier &lt;: SurvivalEstimator</code></pre><p>See <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L267-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.NelsonAalen" href="#SurvivalAnalysis.NelsonAalen"><code>SurvivalAnalysis.NelsonAalen</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NelsonAalen &lt;: SurvivalEstimator</code></pre><p>See <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L369-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.ParametricAFT" href="#SurvivalAnalysis.ParametricAFT"><code>SurvivalAnalysis.ParametricAFT</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParametricAFT{&lt;:ContinuousUnivariateDistribution} &lt;: ParametricSurvival</code></pre><p>See <a href="#SurvivalAnalysis.ParametricSurvival"><code>ParametricSurvival</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L303-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.ParametricPH" href="#SurvivalAnalysis.ParametricPH"><code>SurvivalAnalysis.ParametricPH</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParametricPH{&lt;:ContinuousUnivariateDistribution} &lt;: ParametricSurvival</code></pre><p>See <a href="#SurvivalAnalysis.ParametricSurvival"><code>ParametricSurvival</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L140-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.ParametricSurvival" href="#SurvivalAnalysis.ParametricSurvival"><code>SurvivalAnalysis.ParametricSurvival</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ParametricSurvival &lt;: SurvivalModel</code></pre><p>Abstract type for all fully-parametric survival models implemented in, or extending, this package. Type &#39;inherits&#39; <a href="#SurvivalAnalysis.SurvivalModel"><code>SurvivalModel</code></a>.</p><p>Available methods:</p><ul><li><a href="#StatsAPI.coef-Tuple{SurvivalModel}"><code>coef</code></a> - Extract fitted coefficients</li><li><a href="#StatsAPI.fit-Tuple{Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:SurvivalAnalysis.SurvivalEstimator, AbstractMatrix{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Real, SurvivalAnalysis.RCSurv}"><code>fit</code></a> and <a href="@predict"><code>predict</code></a> - Fit model and make predictions from fitted model with <code>@formula</code> or <code>matrix</code> interface, see <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a></li><li><a href="#SurvivalAnalysis.baseline-Tuple{StatsModels.TableStatisticalModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:SurvivalAnalysis.ParametricSurvival, var&quot;#s30&quot;&lt;:(AbstractMatrix{T} where T)}}"><code>baseline</code></a> - Extract fitted baseline distribution, see <a href="@ref">ph</a> and <a href="@ref">aft</a> for more</li><li><a href="#Distributions.scale-Tuple{StatsModels.TableStatisticalModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:SurvivalAnalysis.ParametricSurvival, var&quot;#s30&quot;&lt;:(AbstractMatrix{T} where T)}}"><code>scale</code></a> - Extract scale parameter of fitted distribution</li></ul><p>All distributions are fitted with the Kalbfleisch-Prentice parametrisation and then converted as required to make use of <code>Distributions.jl</code></p><p>Objects inheriting from this should have the following fields:</p><ul><li><code>coefficients::Vector{Float64}</code> - Fitted coefficients</li><li><code>scale::Float64</code> - Fitted scale parameter for baseline distribution <em>before</em> transformation</li><li><code>hessian::Matrix</code> - Hessian from <code>Optim</code></li><li><code>var_cov::Matrix</code> - Covariance matrix</li><li><code>tstats::Vector</code> - t-statistics</li><li><code>baseline&lt;:ContinuousUnivariateDistribution</code> - Fitted baseline distribution</li><li><code>routine</code> - Optimisation routine from <code>Optim</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L4-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.Surv" href="#SurvivalAnalysis.Surv"><code>SurvivalAnalysis.Surv</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Surv
OneSidedSurv &lt;: Surv
TwoSidedSurv &lt;:Surv
RCSurv &lt;: OneSidedSurv
LCSurv &lt;: OneSidedSurv
IntSurv &lt;: TwoSidedSurv</code></pre><p><code>Surv</code> is the abstract type for all survival outcome representations in this package. See <a href="#SurvivalAnalysis.Surv"><code>Surv</code></a> for constructing a <code>Surv</code> object.</p><p>Available methods:</p><ul><li><a href="#Base.length-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>length</code></a> - Get length of a survival object</li><li><a href="#SurvivalAnalysis.outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>outcome_times</code></a> - Get times at which an outcome (event or censoring) takes place</li><li><a href="#SurvivalAnalysis.event_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>event_times</code></a> - Get times at which an event (not censoring) takes place</li><li><a href="#SurvivalAnalysis.outcome_status-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>outcome_status</code></a> - Get vector of survival indicators</li><li><a href="#SurvivalAnalysis.unique_outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>unique_outcome_times</code></a> - Get unique times at which an outcome takes place</li><li><a href="#SurvivalAnalysis.unique_event_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>unique_event_times</code></a> - Get unique times at which an event takes place</li><li><a href="#SurvivalAnalysis.total_events-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>total_events</code></a> - Get total number of events (optionally at a given time)</li><li><a href="#SurvivalAnalysis.total_censored-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>total_censored</code></a> - Get total number censored (optionally at a given time)</li><li><a href="#SurvivalAnalysis.total_outcomes-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>total_outcomes</code></a> - Get total number of outcomes (optionally at a given time)</li><li><a href="#SurvivalAnalysis.total_risk-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>total_risk</code></a> -  Get total number at risk (optionally at a given time)</li><li><a href="#SurvivalAnalysis.surv_stats-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>surv_stats</code></a> - Get set of useful summary statistics</li><li><a href="#SurvivalAnalysis.threshold_risk-Tuple{SurvivalAnalysis.OneSidedSurv, Number}"><code>threshold_risk</code></a> - Get the time at which a given proportion of observations are no longer at risk</li><li><a href="#Base.merge-Tuple{Vararg{SurvivalAnalysis.OneSidedSurv, N} where N}"><code>merge</code></a> - Merge survival objects</li><li><a href="#Base.reverse-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>reverse</code></a> - Reverse survival outcome (not in-place)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.Surv-Tuple{Union{Vector{T}, T} where T&lt;:Number, Union{Vector{T}, T} where T&lt;:Number}" href="#SurvivalAnalysis.Surv-Tuple{Union{Vector{T}, T} where T&lt;:Number, Union{Vector{T}, T} where T&lt;:Number}"><code>SurvivalAnalysis.Surv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Surv(start, stop)
Surv(time)
Surv(time, status, type)</code></pre><p>Survival analysis is dependent on representing both known and unknown survival time outcomes for an observation. When the true survival time is unknown we say an observation is <em>censored</em> and we instead record their censoring time. Let <span>$(T, Δ)$</span> be a one-sided survival outcome, then <span>$T$</span> is the outcome time (the time at which an outcome, event or censoring, is observed) and <span>$Δ$</span> is the survival indicator (1 if the outcome is an event and 0 if censoring). For example, if a patient drops out of a study at time 5, then they are recorded as <span>$(T=5, Δ=0)$</span>. Two-sided survival outcomes are more simply recorded as <span>$(T₁,T₂)$</span> which means the true event time was somewhere between <span>$T₁$</span> and <span>$T₂$</span>.</p><p>There are three censoring types:</p><ul><li>Right (<code>Surv(time, status, :r)</code> - The true outcome time occurs at some time <em>after</em> the observed censoring time</li><li>Left (<code>Surv(time, status, :l)</code>) - The true outcome time occurs at some time <em>before</em> the observed censoring time</li><li>Interval (<code>Surv(start, stop)</code>) - The true outcome time occurs at some time <em>within</em> the observed censoring times</li></ul><p>If no <code>status</code> vector is passed to the function then it is assumed no-one is censored - this is rarely useful in practice as in this case one could simply use regression models.</p><p>Note❗ Whilst this package supports functionality for all censoring types, currently only methods for right censoring are included.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Surv([1, 2, 3], [true, false, true], :r) # right-censoring
[&quot;1.0&quot;, &quot;2.0+&quot;, &quot;3.0&quot;]

julia&gt; Surv([1, 2, 3], [1, 0, 1], :l) # left-censoring
[&quot;1.0&quot;, &quot;2.0-&quot;, &quot;3.0&quot;]

julia&gt; Surv([1, 2, 3], [5, 6, 7]) # interval-censoring
[(1.0, 5.0), (2.0, 6.0), (3.0, 7.0)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L58-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.SurvivalEstimator" href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalAnalysis.SurvivalEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurvivalEstimator &lt;: StatisticalModel</code></pre><p>Abstract type for all non-parametric estimators implemented in, or extending, this package. Type &#39;inherits&#39; from <a href="https://github.com/JuliaStats/StatsAPI.jl/blob/main/src/statisticalmodel.jl">StatsAPI.StatisticalModel</a> to enable formula fitting and predicting interface. Note❗This may be abstracted further into <code>ConditionalSurvivalEstimator &lt;: SurvivalEstimator</code> and <code>UnconditionalSurvivalEstimator &lt;: SurvivalEstimator</code>.</p><p>Available methods:</p><ul><li><a href="#StatsAPI.fit-Tuple{Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:SurvivalAnalysis.SurvivalEstimator, AbstractMatrix{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Real, SurvivalAnalysis.RCSurv}"><code>fit</code></a> and <a href="#StatsAPI.predict-Tuple{ParametricAFT, AbstractMatrix{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:Real}"><code>predict</code></a> - Fit model and make predictions from fitted model with <code>@formula</code> or <code>matrix</code> interface, see <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a></li><li><a href="#StatsAPI.confint-Tuple{KaplanMeier, Number}"><code>confint</code></a> - Calculate confidence intervals around estimates</li><li><a href="#Base.Libc.time-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>time</code></a> - Extract fitted times</li><li><a href="#SurvivalAnalysis.survival-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>survival</code></a> - Extract estimated survival probabilities</li><li><a href="#Statistics.std-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>std</code></a> - Extract computed standard deviation</li><li><a href="#SurvivalAnalysis.distr-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>distr</code></a> - Extract fitted survival distribution</li></ul><p>Objects inheriting from this should have the following fields:</p><ul><li><code>time::Vector{Float64}</code> - Fitted survival times</li><li><code>survival::Vector{Float64}</code> - Estimated survival probabilities</li><li><code>std::Vector{Float64}</code> - Computed standard deviation</li><li><code>distr::DiscreteNonParametric</code> - Fitted survival distribution</li><li><code>stats::NamedTuple</code> - Summary statistics such as numbers at risk, dead, censored</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L4-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.SurvivalModel" href="#SurvivalAnalysis.SurvivalModel"><code>SurvivalAnalysis.SurvivalModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SurvivalModel &lt;: StatisticalModel</code></pre><p>Abstract type for all models implemented in, or extending, this package. Type &#39;inherits&#39; from <a href="https://github.com/JuliaStats/StatsAPI.jl/blob/main/src/statisticalmodel.jl">StatsAPI.StatisticalModel</a> to enable formula fitting and predicting interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalModel.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.SurvivalPrediction-Union{Tuple{}, Tuple{T}} where T&lt;:Number" href="#SurvivalAnalysis.SurvivalPrediction-Union{Tuple{}, Tuple{T}} where T&lt;:Number"><code>SurvivalAnalysis.SurvivalPrediction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SurvivalPrediction(;
    distr::Union{Nothing, Vector{&lt;:Distribution}} = nothing,
    lp::Union{Nothing, Vector{T}}  = nothing,
    crank::Union{Nothing, Vector{T}} = nothing,
    time::Union{Nothing, Vector{T}} = nothing,
    fit_times::Union{Nothing, Vector{T}} = nothing,
    survival_matrix::Union{Matrix{T}, Nothing} = nothing
    ) where {T&lt;:Number}</code></pre><p>Survival models can make multiple types of predictions including:</p><ul><li><code>distr</code> - A survival time distribution (implemented with <code>Distributions.jl</code>)</li><li><code>lp</code> - A linear predictor (usually Xβ, i.e. covariates * fitted coefficients)</li><li><code>crank</code> - A generic continuous relative risk ranking</li><li><code>time</code> - A survival time</li><li><code>survival_matrix</code> - A matrix of predicted survival probabilities where rows are</li></ul><p>observations and columns are fitted survival times corresponding to <code>fit_times</code>.</p><p>These predictions can only exist in a finite number of combinations so they are aggregated in types within this package (and automatically determined within this function):</p><ul><li><code>DeterministicSurvivalPrediction(lp, crank, time)</code></li><li><code>DiscreteSurvivalPrediction(distr, lp, crank, time, survival_matrix)</code></li><li><code>ContinuousSurvivalPrediction(distr, lp, crank, time)</code></li></ul><p>Absolutely no transformations take require assumptions take place within this function but it does transform <code>survival_matrix</code> to a <code>Distributions.DiscreteNonParametric</code> and vice versa.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; SurvivalPrediction(time = randn(5)); # DeterministicSurvivalPrediction

julia&gt; SurvivalPrediction(fit_times = randn(5), survival_matrix = randn((2, 5))); # DiscreteSurvivalPrediction

julia&gt; SurvivalPrediction(distr = fill(Exponential(), 2)); # ContinuousSurvivalPrediction</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalPrediction.jl#L24-L62">source</a></section></article><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.Libc.time-Tuple{SurvivalAnalysis.SurvivalEstimator}" href="#Base.Libc.time-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>Base.Libc.time</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time(npe::SurvivalEstimator)
time(npe::StatsModels.TableStatisticalModel{&lt;:SurvivalEstimator, &lt;:AbstractMatrix})</code></pre><p>Return fitted times from a <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; time(km(@formula(Srv(Y, D) ~ 1), data))
4-element Vector{Float64}:
 1.0
 4.0
 5.0
 8.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L144-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#Base.length-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">length(srv::OneSidedSurv)
length(srv::TwoSidedSurv)</code></pre><p>Get length of a survival object.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; length(Surv([1, 2, 3], [true, false, true], :r))
3

julia&gt; length(Surv([1, 2, 3], [5, 6, 7]))
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L126-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.merge-Tuple{Vararg{SurvivalAnalysis.OneSidedSurv, N} where N}" href="#Base.merge-Tuple{Vararg{SurvivalAnalysis.OneSidedSurv, N} where N}"><code>Base.merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">merge(A::OneSidedSurv...)
merge(A::TwoSidedSurv...)

Merge survival objects.</code></pre><p><strong>Examples</strong></p><p>```jldoctest julia&gt; srv1 = Surv([1, 2, 3], [false, true, false], :r) [&quot;1.0+&quot;, &quot;2.0&quot;, &quot;3.0+&quot;]</p><p>julia&gt; srv2 = Surv([4, 5, 6], [false, true, true], :r) [&quot;4.0+&quot;, &quot;5.0&quot;, &quot;6.0&quot;]</p><p>julia&gt; merge(srv1, srv2) # OneSidedSurv [&quot;1.0+&quot;, &quot;2.0&quot;, &quot;3.0+&quot;, &quot;4.0+&quot;, &quot;5.0&quot;, &quot;6.0&quot;]</p><p>julia&gt; srv1 = Surv([1, 2, 3], [4, 5, 6]) [(1.0, 4.0), (2.0, 5.0), (3.0, 6.0)]</p><p>julia&gt; srv2 = Surv([7, 8, 9], [10, 11, 12]) [(7.0, 10.0), (8.0, 11.0), (9.0, 12.0)]</p><p>julia&gt; merge(srv1, srv2) # TwoSidedSurv [(1.0, 4.0), (2.0, 5.0), (3.0, 6.0), (7.0, 10.0), (8.0, 11.0), (9.0, 12.0)]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L368-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.reverse-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#Base.reverse-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>Base.reverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reverse(srv::OneSidedSurv)</code></pre><p>Reverse survival outcome (not in-place). Useful for computing non-parametric estimators of the censoring distribution instead of the survival distribution.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; srv = Surv([1, 2, 3, 4, 5, 6], [false, true, false, false, true, true], :r) [&quot;1.0+&quot;, &quot;2.0&quot;, &quot;3.0+&quot;, &quot;4.0+&quot;, &quot;5.0&quot;, &quot;6.0&quot;]</p><p>julia&gt; reverse(srv) [&quot;1.0&quot;, &quot;2.0+&quot;, &quot;3.0&quot;, &quot;4.0&quot;, &quot;5.0+&quot;, &quot;6.0+&quot;]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L413-L426">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Distributions.scale-Tuple{StatsModels.TableStatisticalModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:SurvivalAnalysis.ParametricSurvival, var&quot;#s30&quot;&lt;:(AbstractMatrix{T} where T)}}" href="#Distributions.scale-Tuple{StatsModels.TableStatisticalModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:SurvivalAnalysis.ParametricSurvival, var&quot;#s30&quot;&lt;:(AbstractMatrix{T} where T)}}"><code>Distributions.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scale(mm::StatsModels.TableStatisticalModel{&lt;:ParametricSurvival, &lt;:AbstractMatrix})
scale(mm::ParametricSurvival)</code></pre><p>Extract estimated scale parameter (<em>before</em> transformation) for baseline distribution from fitted <a href="#SurvivalAnalysis.ParametricSurvival"><code>ParametricSurvival</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L96-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe" href="#RecipesBase.apply_recipe"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">plot(npe::SurvivalEstimator, plot_confint::Bool = true; level = 0.95)
plot(npe::StatsModels.TableStatisticalModel{SurvivalEstimator, Matrix{Float64}},
    plot_confint::Bool = true; level = 0.95)</code></pre><p>Recipe for plotting fitted non-parametric estimators, <code>npe</code>. If <code>plot_confint</code> then confidence intervals also plotted at a <code>level</code>% confidence level.</p><p><strong>Examples</strong></p><pre><code class="nohighlight hljs">julia&gt; using Plots

julia&gt; data = DataFrame(t = randn(10), d = [trues(5)..., falses(5)...]);

julia&gt; plot(kaplan_meier(@formula(Srv(t, d) ~ 1), data));

julia&gt; plot(nelson_aalen(@formula(Srv(t, d) ~ 1), data).model);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/plot_survivalestimator.jl#L1-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.std-Tuple{SurvivalAnalysis.SurvivalEstimator}" href="#Statistics.std-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>Statistics.std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">std(npe::SurvivalEstimator)
std(npe::StatsModels.TableStatisticalModel{&lt;:SurvivalEstimator, &lt;:AbstractMatrix})</code></pre><p>Return computed standard deviation from a <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; std(km(@formula(Srv(Y, D) ~ 1), data))
4-element Vector{Float64}:
 1.0004625991132958
 0.712458742539604
 0.6082063644330836
 0.5713145523891875</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L184-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.coef-Tuple{SurvivalModel}" href="#StatsAPI.coef-Tuple{SurvivalModel}"><code>StatsAPI.coef</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">coef(obj::SurvivalModel)</code></pre><p>Extract coefficients from fitted <a href="#SurvivalAnalysis.SurvivalModel"><code>SurvivalModel</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalModel.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.confint-Tuple{KaplanMeier, Number}" href="#StatsAPI.confint-Tuple{KaplanMeier, Number}"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">confint(km::KaplanMeier; level::Float64 = 0.95)
confint(km::KaplanMeier, t::Number; level::Float64 = 0.95)</code></pre><p>Calculate the confidence interval (CI) around a fitted Kaplan-Meier estimate to <code>level</code>% confidence. If <code>t</code> provided then returns CI at that time, otherwise returns CI at all fitted times. Standard deviation is calculated using the pointwise method of Kalbfleisch and Prentice (1980).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; confint(km(@formula(Srv(Y, D) ~ 1), data))
4-element Vector{Tuple{Float64, Float64}}:
 (0.473009271362049, 0.9852813933673431)
 (0.38088152320549545, 0.9425909522237038)
 (0.21830025822743343, 0.8691223292427415)
 (0.0700802713627666, 0.7534316354804488)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L340-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.confint-Tuple{NelsonAalen, Number}" href="#StatsAPI.confint-Tuple{NelsonAalen, Number}"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">confint(na::NelsonAalen; level::Float64 = 0.95)
confint(na::NelsonAalen, t::Number; level::Float64 = 0.95)</code></pre><p>Calculate the confidence interval (CI) around a fitted Nelson-Aalen estimate to <code>level</code>% confidence. If <code>t</code> provided then returns CI at that time, otherwise returns CI at all fitted times.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; confint(na(@formula(Srv(Y, D) ~ 1), data), 10)
(0.23186692958834798, 0.9464141496254767)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L443-L457">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit-Tuple{Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:SurvivalAnalysis.SurvivalEstimator, AbstractMatrix{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Real, SurvivalAnalysis.RCSurv}" href="#StatsAPI.fit-Tuple{Type{var&quot;#s31&quot;} where var&quot;#s31&quot;&lt;:SurvivalAnalysis.SurvivalEstimator, AbstractMatrix{var&quot;#s30&quot;} where var&quot;#s30&quot;&lt;:Real, SurvivalAnalysis.RCSurv}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit(obj::Type{&lt;:SurvivalEstimator}, X::AbstractMatrix{&lt;:Real}, Y::RCSurv)</code></pre><p>Fit a <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a> survival model using matrix interface. It is recommended to use <a href="#SurvivalAnalysis.kaplan_meier-Tuple"><code>kaplan_meier</code></a> or <a href="#SurvivalAnalysis.nelson_aalen-Tuple"><code>nelson_aalen</code></a> directly instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit-Union{Tuple{T}, Tuple{Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:SurvivalAnalysis.ParametricSurvival, AbstractMatrix{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:Real, SurvivalAnalysis.RCSurv, Type{T}}} where T&lt;:Distribution{Univariate, Continuous}" href="#StatsAPI.fit-Union{Tuple{T}, Tuple{Type{var&quot;#s24&quot;} where var&quot;#s24&quot;&lt;:SurvivalAnalysis.ParametricSurvival, AbstractMatrix{var&quot;#s23&quot;} where var&quot;#s23&quot;&lt;:Real, SurvivalAnalysis.RCSurv, Type{T}}} where T&lt;:Distribution{Univariate, Continuous}"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit(t::Type{&lt;:ParametricSurvival}, X::AbstractMatrix{&lt;:Real}, Y::RCSurv,
    d::Type{T}; init::Number = 1) where {T &lt;: ContinuousUnivariateDistribution}</code></pre><p>Fit a <a href="#SurvivalAnalysis.ParametricSurvival"><code>ParametricSurvival</code></a> survival model using matrix interface. It is recommended to use <a href="#SurvivalAnalysis.ph-Tuple"><code>ph</code></a> or <a href="#SurvivalAnalysis.aft-Tuple"><code>aft</code></a> directly instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L32-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{ParametricAFT, AbstractMatrix{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:Real}" href="#StatsAPI.predict-Tuple{ParametricAFT, AbstractMatrix{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:Real}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(fit::ParametricAFT, X::AbstractMatrix{&lt;:Real})
predict(fit::StatsModels.TableStatisticalModel{ParametricAFT, Matrix{Float64}},
    data::DataFrames.DataFrame)</code></pre><p>Make predictions from a fitted <a href="#SurvivalAnalysis.ParametricAFT"><code>ParametricAFT</code></a> model. See <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a> and examples below for predicting interfaces, we recommend using <code>predict(fit, data::DataFrame)</code>.</p><p>Three prediction types can be made from a fitted AFT model:</p><ul><li><code>lp</code> - <span>$Xβ̂$</span></li><li><code>crank</code> - <span>$-Xβ̂$</span></li><li><code>distr</code> - <span>$F(t) = F̂₀(t/exp(Xβ̂))$</span></li></ul><p>where <span>$β̂$</span> are estimated coefficients, <span>$X$</span> are covariates from the new data, and <span>$F̂₀$</span> is the estimated baseline distribution CDF function. Predicted distributions are returned as <code>ContinuousAFTDistribution &lt;: Distributions.ContinuousUnivariateDistribution</code>.</p><p>Note❗The AFT model assumes that a higher linear predictor means a lower risk of event and therefore a higher survival time, i.e., <span>$βXᵢ &gt; βXⱼ → hᵢ(t) &lt; hⱼ(t)$</span> - hence <code>crank = -lp</code>.</p><p>Future updates will add transformation methods for more prediction types (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/12">#12</a>).</p><p>Function returns a <a href="#SurvivalAnalysis.SurvivalPrediction-Union{Tuple{}, Tuple{T}} where T&lt;:Number"><code>SurvivalPrediction</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = [1,1,4,6,8,4,9,4,5,10];

julia&gt; D = [true, false, false, false, true, false, false, true, true, false];

julia&gt; X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];

julia&gt; data = DataFrame(Y = Y, D = D, X = X);

julia&gt; f = aft(@formula(Srv(Y, D) ~ X), data, Exponential);

julia&gt; predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L413-L448">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{ParametricPH, AbstractMatrix{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:Real}" href="#StatsAPI.predict-Tuple{ParametricPH, AbstractMatrix{var&quot;#s32&quot;} where var&quot;#s32&quot;&lt;:Real}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(fit::ParametricPH, X::AbstractMatrix{&lt;:Real})
predict(fit::StatsModels.TableStatisticalModel{ParametricPH, Matrix{Float64}},
    data::DataFrames.DataFrame)</code></pre><p>Make predictions from a fitted <a href="#SurvivalAnalysis.ParametricPH"><code>ParametricPH</code></a> model. See <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a> and examples below for predicting interfaces, we recommend using <code>predict(fit, data::DataFrame)</code>.</p><p>Three prediction types can be made from a fitted PH model:</p><ul><li><code>lp</code> - <span>$Xβ̂$</span></li><li><code>crank</code> - <span>$Xβ̂$</span></li><li><code>distr</code> - <span>$F(t) = 1 - Ŝ₀(t)^{exp(Xβ̂)}$</span></li></ul><p>where <span>$β̂$</span> are estimated coefficients, <span>$X$</span> are covariates from the new data, and <span>$Ŝ₀$</span> is the estimated baseline distribution survival function. Predicted distributions are returned as <code>ContinuousPHDistribution &lt;: Distributions.ContinuousUnivariateDistribution</code>.</p><p>Note❗The PH model assumes that a higher linear predictor means a higher risk of event and therefore a lower survival time, i.e., `<code>βXᵢ &gt; βXⱼ → hᵢ(t) &gt; hⱼ(t)</code> - hence <code>crank = lp</code>. This means when calculating <a href="#SurvivalAnalysis.concordance"><code>concordance</code></a> you <em>must</em> include <code>rev = true</code>.</p><p>Future updates will add transformation methods for more prediction types (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/12">#12</a>).</p><p>Function returns a <a href="#SurvivalAnalysis.SurvivalPrediction-Union{Tuple{}, Tuple{T}} where T&lt;:Number"><code>SurvivalPrediction</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = [1,1,4,6,8,4,9,4,5,10];

julia&gt; D = [true, false, false, false, true, false, false, true, true, false];

julia&gt; X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];

julia&gt; data = DataFrame(Y = Y, D = D, X = X);

julia&gt; f = ph(@formula(Srv(Y, D) ~ X), data, Weibull);

julia&gt; predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L256-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.predict-Tuple{SurvivalAnalysis.SurvivalEstimator, DataFrame}" href="#StatsAPI.predict-Tuple{SurvivalAnalysis.SurvivalEstimator, DataFrame}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">predict(fit::SurvivalEstimator, X::AbstractMatrix{&lt;:Real})
predict(fit::StatsModels.TableStatisticalModel{SurvivalEstimator, Matrix{Float64}},
    data::DataFrames.DataFrame)</code></pre><p>Make predictions from a fitted <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a> model. See <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a> and examples below for predicting interfaces, we recommend using <code>predict(fit, data::DataFrame)</code>.</p><p>Two prediction types can be made from a non-parametric estimator:</p><ul><li><code>distr</code> - See <a href="#SurvivalAnalysis.kaplan_meier-Tuple"><code>kaplan_meier</code></a> or <a href="#SurvivalAnalysis.nelson_aalen-Tuple"><code>nelson_aalen</code></a> for formulae</li><li><code>survival_matrix</code> - Matrix of survival probabilities</li></ul><p>Predicted distributions are returned as <code>Distributions.DiscreteNonParametric</code>.</p><p>Function returns a <a href="#SurvivalAnalysis.SurvivalPrediction-Union{Tuple{}, Tuple{T}} where T&lt;:Number"><code>SurvivalPrediction</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; f = km(@formula(Srv(Y, D) ~ 1), data);

julia&gt; predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L46-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.Srv" href="#SurvivalAnalysis.Srv"><code>SurvivalAnalysis.Srv</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Srv(T::Symbol, Δ::Symbol, type::Int = 1)</code></pre><p>Create a <code>SurvTerm</code> object for internal use for fitting models. Arguments, <code>T</code> and <code>Δ</code> should be a reference to the name of the time and status variables in a <code>DataFrame</code> respectively. <code>type</code> should be <code>1</code> (or omitted) for right-censoring or <code>-1</code> for left-censoring.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; @formula(Srv(t, d) ~ 1) # right-censoring
FormulaTerm
Response:
  (t,d)-&gt;Srv(t, d)
Predictors:
  1

julia&gt; @formula(Srv(t, d, -1) ~ X) # left-censoring
FormulaTerm
Response:
  (t,d)-&gt;Srv(t, d, -1)
Predictors:
  X(unknown)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvTerm.jl#L13-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.aft-Tuple" href="#SurvivalAnalysis.aft-Tuple"><code>SurvivalAnalysis.aft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aft(f::@formula, data::DataFrames.DataFrame, d::Type{T}; init::Number = 1)
aft(X::AbstractMatrix{&lt;:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)
fit(ParametricAFT, X::AbstractMatrix{&lt;:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)</code></pre><p>Fit a fully-parametric accelerated failure time (AFT) model with baseline distribution <code>d</code>. See <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a> and examples below for fitting interfaces, we recommend using <code>aft(::@formula...)</code>.</p><p>Fully-parametric AFT models are defined by</p><p class="math-container">\[h(t) = e^{-Xβ} h₀(t e^{-Xβ})\]</p><p>where <span>$β$</span> are coefficients to be estimated, <span>$X$</span> are covariates, and <code>h₀</code> is the hazard function of an assumed baseline distribution, <code>d</code>. Available choices for distributions are:</p><ul><li>Distributions.Exponential</li><li>Distributions.Weibull</li></ul><p>AFT models assumes that an increase in a covariate results in an acceleration of the event by a constant. This is best explained by example. The above formula can also be expressed as <span>$S(t) = S₀(exp(-η)t)$</span> then let <span>$ηᵢ = log(2)$</span> and <span>$ηⱼ = log(1)$</span> so <span>$ηᵢ &gt; ηⱼ$</span>. Then Sᵢ(t) = S₀(0.5t) and Sⱼ(t) = S₀(t) and so for all <span>$t$</span>, <span>$Sᵢ(t) ≥ Sⱼ(t)$</span> as S is a decreasing function.</p><p>Future additions:</p><ul><li>More baseline distributions (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/15">#15</a>)</li></ul><p>Function returns a <a href="#SurvivalAnalysis.ParametricAFT"><code>ParametricAFT</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = [1,1,4,6,8,4,9,4,5,10];

julia&gt; D = [true, false, false, false, true, false, false, true, true, false];

julia&gt; X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];

julia&gt; data = DataFrame(Y = Y, D = D, X = X);

julia&gt; f = aft(@formula(Srv(Y, D) ~ X), data, Weibull)
StatsModels.TableStatisticalModel{ParametricAFT{Weibull}, Matrix{Float64}}

(Y,D;+) ~ 1 + X

Distr:
Weibull{Float64}(α=1.7439548025959823, θ=11.754846456706442)

Coefficients:
  (Scale)  (Intercept)            X
 0.573409      2.46427  -0.00741527</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L332-L380">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.baseline-Tuple{StatsModels.TableStatisticalModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:SurvivalAnalysis.ParametricSurvival, var&quot;#s30&quot;&lt;:(AbstractMatrix{T} where T)}}" href="#SurvivalAnalysis.baseline-Tuple{StatsModels.TableStatisticalModel{var&quot;#s31&quot;, var&quot;#s30&quot;} where {var&quot;#s31&quot;&lt;:SurvivalAnalysis.ParametricSurvival, var&quot;#s30&quot;&lt;:(AbstractMatrix{T} where T)}}"><code>SurvivalAnalysis.baseline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">baseline(mm::StatsModels.TableStatisticalModel{&lt;:ParametricSurvival, &lt;:AbstractMatrix})
baseline(mm::ParametricSurvival)</code></pre><p>Extract baseline distribution from fitted <a href="#SurvivalAnalysis.ParametricSurvival"><code>ParametricSurvival</code></a> object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L86-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.concordance" href="#SurvivalAnalysis.concordance"><code>SurvivalAnalysis.concordance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">concordance(
    truth::OneSidedSurv, prediction::Vector{&lt;:Number}, weights::Union{Symbol, ConcordanceWeights};
    tied_preds=0.5, tied_times=0, cutoff=nothing, train::OneSidedSurv=nothing, rev=false
)

Aliases: cindex</code></pre><p>Generic function to call any concordance index method. Concordance is a measure of discrimination which evaluates if a prediction is concordant with the truth, i.e. let Tᵢ,Tⱼ be the true survival times, <code>truth</code>, for observations <code>i</code> and <code>j</code> and let  ϕᵢ, ϕⱼ be predictions, <code>prediction</code>, then these are concordant if <span>$ϕᵢ &gt; ϕⱼ ⟺ Tᵢ &gt; Tⱼ$</span>.</p><p>In survival analysis the generic C-index is defined as follows</p><p class="math-container">\[C = \frac{\sum_{i≠j} W(tᵢ)I(tᵢ &lt; tⱼ, yᵢ &lt; yⱼ, tᵢ &lt; τ)δᵢ}{W(tᵢ)I(tᵢ &lt; tⱼ, tᵢ &lt; τ)δᵢ}\]</p><p>where <code>tᵢ,tⱼ</code> are true survival times, <code>yᵢ,yⱼ</code> are predictions, <code>τ</code> is a cutoff time used to ensure stability even when censoring is high, <code>δᵢ</code> is the censoring indicator and <code>W</code> is a weighting function determined by <code>weights</code> as follows:</p><ul><li><code>:I</code> or <code>:Harrell</code> - Harrell&#39;s C - <span>$W(tᵢ) = 1$</span></li><li><code>:G2</code> or <code>:Uno</code> - Uno&#39;s C - <span>$W(tᵢ) = 1/G(tᵢ)$</span></li><li><code>:SG</code> or <code>:Schemper</code> - Schemper&#39;s C - <span>$W(tᵢ) = S(tᵢ)/G(tᵢ)$</span></li><li><code>:S</code> or <code>:Peto</code> - Peto-Wilcoxon&#39;s C - <span>$W(tᵢ) = S(tᵢ)$</span></li></ul><p>where <code>S(tᵢ)</code> and <code>G(tᵢ)</code> are respectively the Kaplan-Meier estimates of the survival and censoring distributions of the training data at time <code>tᵢ</code>. For any other combination of weights pass a <a href="#SurvivalAnalysis.ConcordanceWeights"><code>ConcordanceWeights</code></a> object to <code>weights</code>. Note❗If training data is not provided to <code>train</code> then <code>truth</code> is used to estimate <code>S</code> and <code>G</code> but it is strongly recommended to provide the training data if possibe.</p><p>We also include an implementation of Gönen-Heller&#39;s C with <code>weights = :GH</code> or <code>:Gonen</code>. Note❗This is actually a very different method from the others and calculates concordance for predictions from a Cox PH model only. We may move this to its own function in the future to avoid misuse.</p><p>There is open debate about how to handle ties when calculating the concordance. Ties can occur in predictions and in the observed survival times. The defaults here <code>tied_preds=0.5</code> and <code>tied_times=0</code> are set as these seem to be the most common but they can be changed. Note❗If you pass a <a href="#SurvivalAnalysis.ConcordanceWeights"><code>ConcordanceWeights</code></a> object then the tied weights specified in this will take priority.</p><p>Note❗For predictions from PH models or any model where the prediction represents a relative risk then a higher value of ϕ implies a higher risk of event which will result in a <em>lower</em> survival time. In this case a prediction is concordant with the survival time if <span>$ϕᵢ &lt; ϕⱼ ⟺ Tᵢ &gt; Tⱼ$</span>. To do this within the function just set <code>rev=true</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; T = [1.0,0.1,pi,0.9,0.4,20,1,5,9,2.5];

julia&gt; ϕ = [0.1,0.2,0.1,0.9,0.25,exp(2),8,log(9),2,8];

julia&gt; Δ = [true,true,false,true,true,false,true,false,true,true];

julia&gt; Y = Surv(T, Δ, :r);

julia&gt; train = Surv([3,3,9,12,2,1,8,4,10,8], Δ, :r);

julia&gt; concordance(Y, ϕ, cutoff = threshold_risk(Y, 0.8)) # Harrell&#39;s C cutoff when 80% data is censored or dead
SurvivalAnalysis.Concordance

Harrell&#39;s C = 0.6153846153846154

Cutoff: T ≤ 9.0
Counts:
 Pairs  Comparable  Concordant  Disconcordant
    90          39          23             14
Weights:
 IPCW  Tied preds  Tied times
    1         0.5         0.0
Ties:
 Times  Preds  Both
     1      2     0
Weighted calculation:
 Numerator  Denominator         C
      24.0         39.0  0.615385

julia&gt; concordance(Y, ϕ, :Uno, train=train) # Uno&#39;s C
SurvivalAnalysis.Concordance

Uno&#39;s C = 0.6221374045801525

Cutoff: T ≤ 20.0
Counts:
 Pairs  Comparable  Concordant  Disconcordant
    90          39          23             14
Weights:
 IPCW  Tied preds  Tied times
 1/G²         0.5         0.0
Ties:
 Times  Preds  Both
     1      2     0
Weighted calculation:
 Numerator  Denominator         C
   28.1728       45.284  0.622137

julia&gt; cindex(Y, ϕ, ConcordanceWeights(5, -3, 0.5, 0.5, &quot;Silly Weights&quot;); train=train) # Custom weights
SurvivalAnalysis.Concordance

Silly Weights C = 0.6070334788405888

Cutoff: T ≤ 20.0
Counts:
 Pairs  Comparable  Concordant  Disconcordant
    90          40          23             14
Weights:
  IPCW  Tied preds  Tied times
 S⁵/G³         0.5         0.5
Ties:
 Times  Preds  Both
     1      2     0
Weighted calculation:
 Numerator  Denominator         C
   25.6265       42.216  0.607033</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/concordance.jl#L75-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.cum_hazard-Tuple{UnivariateDistribution{S} where S&lt;:ValueSupport, Real}" href="#SurvivalAnalysis.cum_hazard-Tuple{UnivariateDistribution{S} where S&lt;:ValueSupport, Real}"><code>SurvivalAnalysis.cum_hazard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cum_hazard(d::UnivariateDistribution, x::Real)

Aliases: Hₜ</code></pre><p>Compute the cumulative hazard function of distribution <code>d</code> at point <code>x</code>.</p><p>The cumulative hazard function for random variable <span>$t$</span> is defined as</p><p class="math-container">\[H_t(x) = \int^x_0 h_t(u) du = -log(S_t(x))\]</p><p>where <span>$hₜ$</span> is the hazard function of <span>$t$</span> and <span>$Sₜ$</span> is the survival function of <span>$t$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; cum_hazard(Binomial(5, 0.5), 3)
1.6739764335716711</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/tools.jl#L29-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.distr-Tuple{SurvivalAnalysis.SurvivalEstimator}" href="#SurvivalAnalysis.distr-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>SurvivalAnalysis.distr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">distr(npe::SurvivalEstimator)
distr(npe::StatsModels.TableStatisticalModel{&lt;:SurvivalEstimator, &lt;:AbstractMatrix})</code></pre><p>Return estimated survival distribution from a <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; distr(km(@formula(Srv(Y, D) ~ 1), data))
DiscreteNonParametric{Float64, Float64, Vector{Float64}, Vector{Float64}}(
support: [0.0, 1.0, 4.0, 5.0, 8.0]
p: [0.0, 0.11250000000000004, 0.15749999999999997, 0.20999999999999996]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L204-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.event_times-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.event_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.event_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outcome_times(srv::OneSidedSurv)</code></pre><p>Get times at which an event (not censoring) takes place.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; event_times(Surv([1, 2, 3], [true, false, true], :r)) 2-element Vector{Float64}:  1.0  3.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L169-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.hazard-Tuple{UnivariateDistribution{S} where S&lt;:ValueSupport, Real}" href="#SurvivalAnalysis.hazard-Tuple{UnivariateDistribution{S} where S&lt;:ValueSupport, Real}"><code>SurvivalAnalysis.hazard</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hazard(d::UnivariateDistribution, x::Real)

Aliases: hₜ</code></pre><p>Compute the hazard function of distribution <code>d</code> at point <code>x</code>.</p><p>The hazard function for random variable <span>$t$</span> is defined as</p><p class="math-container">\[h_t(x) = \frac{f_t(x)}{S_t(x)}\]</p><p>where <span>$fₜ$</span> is the pdf of <span>$t$</span> and <span>$Sₜ$</span> is the survival function of <span>$t$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Distributions

julia&gt; hazard(Binomial(5, 0.5), 3)
1.6666666666666679</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/tools.jl#L4-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.kaplan_meier-Tuple" href="#SurvivalAnalysis.kaplan_meier-Tuple"><code>SurvivalAnalysis.kaplan_meier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kaplan_meier(Y::RCSurv)
kaplan_meier(f::@formula, data::DataFrames.DataFrame)
kaplan_meier(X::AbstractMatrix{&lt;:Real}, Y::RCSurv)
fit(KaplanMeier, X::AbstractMatrix{&lt;:Real}, Y::RCSurv)

Aliases: km, kaplan</code></pre><p>Fit a non-parametric Kaplan-Meier estimator on a right-censored survival outcome. See <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a> and examples below for fitting interfaces, we recommend using <code>kaplan_meier(::@formula...)</code> (or aliases).</p><p>The Kaplan-Meier Estimator is defined by</p><p class="math-container">\[Ŝ(τ) = ∏_{i:tᵢ≤τ} (1 - \frac{dᵢ}{nᵢ})\]</p><p>where <span>$dᵢ$</span> and <span>$nᵢ$</span> are the number of events and nunber at risk at time <span>$tᵢ$</span> respectively.</p><p>Standard deviation is calculated using the pointwise method of Kalbfleisch and Prentice (1980).</p><p>Future additions:</p><ul><li>Support for other censoring types (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/46">#46</a>)</li><li>Support for stratified estimator (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/47">#47</a>)</li></ul><p>Function returns a <a href="#SurvivalAnalysis.KaplanMeier"><code>KaplanMeier</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; f = kaplan_meier(@formula(Srv(Y, D) ~ 1), data)
StatsModels.TableStatisticalModel{KaplanMeier, Matrix{Float64}}

(Y,D;+) ~ 1

Coefficients:
  n  ncens  nevents
 10      6        4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L282-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.nelson_aalen-Tuple" href="#SurvivalAnalysis.nelson_aalen-Tuple"><code>SurvivalAnalysis.nelson_aalen</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nelson_aalen(Y::RCSurv)
nelson_aalen(f::@formula, data::DataFrames.DataFrame)
nelson_aalen(X::AbstractMatrix{&lt;:Real}, Y::RCSurv)
fit(NelsonAalen, X::AbstractMatrix{&lt;:Real}, Y::RCSurv)

Aliases: na, nelson</code></pre><p>Fit a non-parametric Nelson-NelsonAalen estimator on a right-censored survival outcome. See <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a> and examples below for fitting interfaces, we recommend using <code>nelson_aalen(::@formula...)</code> (or aliases).</p><p>The Nelson-Aalen Estimator is defined by</p><p class="math-container">\[Ĥ(τ) = ∑_{i:tᵢ≤τ} \frac{dᵢ}{nᵢ}\]</p><p>where <span>$dᵢ$</span> and <span>$nᵢ$</span> are the number of events and nunber at risk at time <span>$tᵢ$</span> respectively and Ĥ is the estimated cumulative hazard function. The survival function is then Ŝ = exp(-Ĥ).</p><p>Future additions:</p><ul><li>Support for other censoring types (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/46">#46</a>)</li><li>Support for stratified estimator (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/47">#47</a>)</li></ul><p>Function returns a <a href="#SurvivalAnalysis.NelsonAalen"><code>NelsonAalen</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; f = nelson_aalen(@formula(Srv(Y, D) ~ 1), data)
StatsModels.TableStatisticalModel{NelsonAalen, Matrix{Float64}}

(Y,D;+) ~ 1

Coefficients:
  n  ncens  nevents
 10      6        4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L384-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.outcome_status-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.outcome_status-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.outcome_status</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outcome_status(srv::OneSidedSurv)

Get vector of survival indicators.</code></pre><p><strong>Examples</strong></p><p>```jldoctest julia&gt; outcome_status(Surv([1, 2, 3], [true, false, true], :r)) 3-element Vector{Bool}:  1  0  1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L184-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.outcome_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">outcome_times(srv::OneSidedSurv)
outcome_times(srv::TwoSidedSurv)

Get times at which an outcome (event or censoring) takes place.</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; outcome_times(Surv([1, 2, 3], [true, false, true], :r))
3-element Vector{Float64}:
 1.0
 2.0
 3.0

julia&gt; outcome_times(Surv([1, 2, 3], [5, 6, 7]))
2-element Vector{Vector{Float64}}:
 [1.0, 2.0, 3.0]
 [5.0, 6.0, 7.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L145-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.ph-Tuple" href="#SurvivalAnalysis.ph-Tuple"><code>SurvivalAnalysis.ph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ph(f::@formula, data::DataFrames.DataFrame, d::Type{T}; init::Number = 1)
ph(X::AbstractMatrix{&lt;:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)
fit(ParametricPH, X::AbstractMatrix{&lt;:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)</code></pre><p>Fit a fully-parametric proportional hazards (PH) model with baseline distribution <code>d</code>. See <a href="../howto/#Fitting-and-predicting">Fitting and predicting</a> and examples below for fitting interfaces, we recommend using <code>ph(::@formula...)</code>.</p><p>Fully-parametric PH models are defined by</p><p class="math-container">\[h(t) = h₀(t)exp(Xβ)\]</p><p>where <span>$β$</span> are coefficients to be estimated, <span>$X$</span> are covariates, and <code>h₀</code> is the hazard function of an assumed baseline distribution, <code>d</code>. Available choices for distributions are:</p><ul><li>Distributions.Exponential</li><li>Distributions.Weibull</li></ul><p>No other distributions have the PH assumption, which assumes that the risk of an event taking place is constant over time.</p><p>Future additions:</p><ul><li>Methods for testing if the assumption is valid for your data (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/11">#11</a>).</li><li>Methods to calculate hazards ratios and add to <code>show</code> (see <a href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/issues/40">#40</a>).</li></ul><p>Function returns a <a href="#SurvivalAnalysis.ParametricPH"><code>ParametricPH</code></a> struct.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Y = [1,1,4,6,8,4,9,4,5,10];

julia&gt; D = [true, false, false, false, true, false, false, true, true, false];

julia&gt; X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];

julia&gt; data = DataFrame(Y = Y, D = D, X = X);

julia&gt; f = ph(@formula(Srv(Y, D) ~ X), data, Exponential)
StatsModels.TableStatisticalModel{ParametricPH{Exponential}, Matrix{Float64}}

(Y,D;+) ~ 1 + X

Distr:
Exponential{Float64}(θ=17.121272620254064)

Coefficients:
 (Scale)  (Intercept)          X
     1.0     -2.84032  0.0101247</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/ParametricSurvival.jl#L169-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.surv_stats-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.surv_stats-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.surv_stats</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">surv_stats(srv::OneSidedSurv; events_only = false)</code></pre><p>Get set of useful summary statistics over time - if <code>events_only = false</code> (default) then returned for all outcomes, otherwise only return the times at which an event occurred (useful for computing non-parametric estimators).</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; surv_stats(Surv([1, 2, 3], [false, true, false], :r)) (time = [1.0, 2.0, 3.0], nrisk = [3, 2, 1], ncens = [1, 0, 1], nevents = [0, 1, 0], noutcomes = [1, 1, 1])</p><p>julia&gt; surv<em>stats(Surv([1, 2, 3], [false, true, false], :r); events</em>only = true) (time = [2.0], nrisk = [2], ncens = [0], nevents = [1], noutcomes = [1])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L314-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.survival-Tuple{SurvivalAnalysis.SurvivalEstimator}" href="#SurvivalAnalysis.survival-Tuple{SurvivalAnalysis.SurvivalEstimator}"><code>SurvivalAnalysis.survival</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">survival(npe::SurvivalEstimator)
survival(npe::StatsModels.TableStatisticalModel{&lt;:SurvivalEstimator, &lt;:AbstractMatrix})</code></pre><p>Return fitted survival probabilities from a <a href="#SurvivalAnalysis.SurvivalEstimator"><code>SurvivalEstimator</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);

julia&gt; survival(km(@formula(Srv(Y, D) ~ 1), data))
4-element Vector{Float64}:
 0.9
 0.7875
 0.63
 0.42000000000000004</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/SurvivalEstimator.jl#L164-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.threshold_risk-Tuple{SurvivalAnalysis.OneSidedSurv, Number}" href="#SurvivalAnalysis.threshold_risk-Tuple{SurvivalAnalysis.OneSidedSurv, Number}"><code>SurvivalAnalysis.threshold_risk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">threshold_risk(srv::OneSidedSurv, p::Number)</code></pre><p>Get the time at which a given proportion of observations are no longer at risk. Useful when computing metrics and calculations become increasingly unstable as number of observations at risk decreases over time.</p><p><strong>Examples</strong></p><p>```jldoctest</p><p><strong>time at which 80% of observations have experienced the event or been censored</strong></p><p>julia&gt; threshold_risk(Surv([1, 2, 3, 4, 5, 6], [false, true, false, false, true, true], :r), 0.8) 6.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L333-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.total_censored-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.total_censored-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.total_censored</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_censored(srv::OneSidedSurv)
total_censored(srv::OneSidedSurv, t::Number)</code></pre><p>Get total number censored (optionally at a given time).</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; total_censored(Surv([1, 2, 3], [false, true, false], :r)) 2</p><p>julia&gt; total_censored(Surv([1, 2, 3], [true, false, true], :r), 3) 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L246-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.total_events-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.total_events-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.total_events</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_events(srv::OneSidedSurv)
total_events(srv::OneSidedSurv, t::Number)</code></pre><p>Get total number of events (optionally at a given time).</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; total_events(Surv([1, 2, 3], [true, false, true], :r)) 2</p><p>julia&gt; total_events(Surv([1, 2, 3], [true, false, true], :r), 3) 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L229-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.total_outcomes-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.total_outcomes-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.total_outcomes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_outcomes(srv::OneSidedSurv)
total_outcomes(srv::OneSidedSurv, t::Number)</code></pre><p>Get total number of outcomes (optionally at a given time).</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; total_outcomes(Surv([1, 2, 3], [false, true, false], :r)) 3</p><p>julia&gt; total_outcomes(Surv([1, 2, 3], [true, false, true], :r), 3) 1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L263-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.total_risk-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.total_risk-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.total_risk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">total_risk(srv::OneSidedSurv)
total_risk(srv::OneSidedSurv, t::Number)</code></pre><p>Get total number at risk (optionally at a given time).</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; total_risk(Surv([1, 2, 3], [false, true, false], :r)) 3</p><p>julia&gt; total_risk(Surv([1, 2, 3], [true, false, true], :r), 2) 2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L280-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.unique_event_times-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.unique_event_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.unique_event_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique_event_times(srv::OneSidedSurv)</code></pre><p>Get unique times at which an event takes place.</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; unique<em>event</em>times(Surv([1, 2, 1], [true, false, true], :r)) 1-element Vector{Float64}:  1.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L215-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SurvivalAnalysis.unique_outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}" href="#SurvivalAnalysis.unique_outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}"><code>SurvivalAnalysis.unique_outcome_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unique_outcome_times(srv::OneSidedSurv)</code></pre><p>Get unique times at which an outcome takes place</p><p><strong>Examples</strong></p><p>```jldoctest julia&gt; unique<em>outcome</em>times(Surv([1, 2, 1], [true, false, true], :r)) 2-element Vector{Float64}:  1.0  2.0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/RaphaelS1/SurvivalAnalysis.jl/blob/1e0d1b8d1936d8cff1d62c3651bdd217897b0c6a/src/Surv.jl#L200-L212">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../explanations/">« Explanations</a><a class="docs-footer-nextpage" href="../news/">Changelog »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 27 August 2022 17:57">Saturday 27 August 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
