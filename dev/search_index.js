var documenterSearchIndex = {"docs":
[{"location":"howto/#How-to-guides","page":"How-to guides","title":"How-to guides","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"More coming soon...","category":"page"},{"location":"howto/#Fitting-and-predicting","page":"How-to guides","title":"Fitting and predicting","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"DocTestSetup = quote\n    using DataFrames, Distributions, SurvivalAnalysis, Random\nend","category":"page"},{"location":"howto/#Fitting","page":"How-to guides","title":"Fitting","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"Models can be fit in one of four ways but we only recommend the first.","category":"page"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"julia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false])\n10×2 DataFrame\n Row │ Y      D\n     │ Int64  Bool\n─────┼──────────────\n   1 │     1   true\n   2 │     1  false\n   3 │     4  false\n   4 │     6  false\n   5 │     8   true\n   6 │     4  false\n   7 │     9  false\n   8 │     4   true\n   9 │     5   true\n  10 │    10  false","category":"page"},{"location":"howto/#.-Function-Formula","page":"How-to guides","title":"1. Function + Formula","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"julia> f = kaplan_meier(@formula(Srv(Y, D) ~ 1), data)\nStatsModels.TableStatisticalModel{KaplanMeier, Matrix{Float64}}\n\n(Y,D;+) ~ 1\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"howto/#.-fit-Formula","page":"How-to guides","title":"2. fit + Formula","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"julia>  f = fit(KaplanMeier, @formula(Srv(Y, D) ~ 1), data)\nStatsModels.TableStatisticalModel{KaplanMeier, Matrix{Float64}}\n\n(Y,D;+) ~ 1\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"howto/#.-Function-Data","page":"How-to guides","title":"3. Function + Data","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"julia> f = kaplan_meier(hcat(ones(10), 1:10), Surv(data.Y, data.D, :r))\nKaplanMeier\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"howto/#.-fit-Data","page":"How-to guides","title":"4. fit + Data","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"julia> f = fit(KaplanMeier, hcat(ones(10), 1:10), Surv(data.Y, data.D, :right))\nKaplanMeier\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"howto/#Predicting","page":"How-to guides","title":"Predicting","text":"","category":"section"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"If fitting method (1) or (2) are selected then new data must be given as a DataFrame, otherwise a Matrix is sufficient. We strongly recommend the formula method as this ensures the same covariates and predictors are used in fitting and predicting.","category":"page"},{"location":"howto/","page":"How-to guides","title":"How-to guides","text":"julia> f = kaplan_meier(@formula(Srv(Y, D) ~ 1), data);\n\njulia> predict(f, DataFrame(Y = randn(10), D = trues(10)));","category":"page"},{"location":"api/#API","page":"Reference (API)","title":"API","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"DocTestSetup = quote\n    using DataFrames, Distributions, SurvivalAnalysis\nend","category":"page"},{"location":"api/#Surv","page":"Reference (API)","title":"Surv","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"Surv.jl\", \"SurvTerm.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#SurvivalAnalysis.Surv","page":"Reference (API)","title":"SurvivalAnalysis.Surv","text":"Surv\nOneSidedSurv <: Surv\nTwoSidedSurv <:Surv\nRCSurv <: OneSidedSurv\nLCSurv <: OneSidedSurv\nIntSurv <: TwoSidedSurv\n\nSurv is the abstract type for all survival outcome representations in this package. See Surv for constructing a Surv object.\n\nAvailable methods:\n\nlength - Get length of a survival object\noutcome_times - Get times at which an outcome (event or censoring) takes place\nevent_times - Get times at which an event (not censoring) takes place\noutcome_status - Get vector of survival indicators\nunique_outcome_times - Get unique times at which an outcome takes place\nunique_event_times - Get unique times at which an event takes place\ntotal_events - Get total number of events (optionally at a given time)\ntotal_censored - Get total number censored (optionally at a given time)\ntotal_outcomes - Get total number of outcomes (optionally at a given time)\ntotal_risk -  Get total number at risk (optionally at a given time)\nsurv_stats - Get set of useful summary statistics\nthreshold_risk - Get the time at which a given proportion of observations are no longer at risk\nmerge - Merge survival objects\nreverse - Reverse survival outcome (not in-place)\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.Surv-Tuple{Union{Vector{T}, T} where T<:Number, Union{Vector{T}, T} where T<:Number}","page":"Reference (API)","title":"SurvivalAnalysis.Surv","text":"Surv(start, stop)\nSurv(time)\nSurv(time, status, type)\n\nSurvival analysis is dependent on representing both known and unknown survival time outcomes for an observation. When the true survival time is unknown we say an observation is censored and we instead record their censoring time. Let (T Δ) be a one-sided survival outcome, then T is the outcome time (the time at which an outcome, event or censoring, is observed) and Δ is the survival indicator (1 if the outcome is an event and 0 if censoring). For example, if a patient drops out of a study at time 5, then they are recorded as (T=5 Δ=0). Two-sided survival outcomes are more simply recorded as (T₁T₂) which means the true event time was somewhere between T₁ and T₂.\n\nThere are three censoring types:\n\nRight (Surv(time, status, :r) - The true outcome time occurs at some time after the observed censoring time\nLeft (Surv(time, status, :l)) - The true outcome time occurs at some time before the observed censoring time\nInterval (Surv(start, stop)) - The true outcome time occurs at some time within the observed censoring times\n\nIf no status vector is passed to the function then it is assumed no-one is censored - this is rarely useful in practice as in this case one could simply use regression models.\n\nNote❗ Whilst this package supports functionality for all censoring types, currently only methods for right censoring are included.\n\nExamples\n\njulia> Surv([1, 2, 3], [true, false, true], :r) # right-censoring\n[\"1.0\", \"2.0+\", \"3.0\"]\n\njulia> Surv([1, 2, 3], [1, 0, 1], :l) # left-censoring\n[\"1.0\", \"2.0-\", \"3.0\"]\n\njulia> Surv([1, 2, 3], [5, 6, 7]) # interval-censoring\n[(1.0, 5.0), (2.0, 6.0), (3.0, 7.0)]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.length-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"Base.length","text":"length(srv::OneSidedSurv)\nlength(srv::TwoSidedSurv)\n\nGet length of a survival object.\n\nExamples\n\njulia> length(Surv([1, 2, 3], [true, false, true], :r))\n3\n\njulia> length(Surv([1, 2, 3], [5, 6, 7]))\n3\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.merge-Tuple{Vararg{SurvivalAnalysis.OneSidedSurv, N} where N}","page":"Reference (API)","title":"Base.merge","text":"merge(A::OneSidedSurv...)\nmerge(A::TwoSidedSurv...)\n\nMerge survival objects.\n\nExamples\n\njulia> srv1 = Surv([1, 2, 3], [false, true, false], :r)\n[\"1.0+\", \"2.0\", \"3.0+\"]\n\njulia> srv2 = Surv([4, 5, 6], [false, true, true], :r)\n[\"4.0+\", \"5.0\", \"6.0\"]\n\njulia> merge(srv1, srv2) # OneSidedSurv\n[\"1.0+\", \"2.0\", \"3.0+\", \"4.0+\", \"5.0\", \"6.0\"]\n\njulia> srv1 = Surv([1, 2, 3], [4, 5, 6])\n[(1.0, 4.0), (2.0, 5.0), (3.0, 6.0)]\n\njulia> srv2 = Surv([7, 8, 9], [10, 11, 12])\n[(7.0, 10.0), (8.0, 11.0), (9.0, 12.0)]\n\njulia> merge(srv1, srv2) # TwoSidedSurv\n[(1.0, 4.0), (2.0, 5.0), (3.0, 6.0), (7.0, 10.0), (8.0, 11.0), (9.0, 12.0)]\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.reverse-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"Base.reverse","text":"reverse(srv::OneSidedSurv)\n\nReverse survival outcome (not in-place). Useful for computing non-parametric estimators of the censoring distribution instead of the survival distribution.\n\nExamples\n\njulia> srv = Surv([1, 2, 3, 4, 5, 6], [false, true, false, false, true, true], :r)\n[\"1.0+\", \"2.0\", \"3.0+\", \"4.0+\", \"5.0\", \"6.0\"]\n\njulia> reverse(srv)\n[\"1.0\", \"2.0+\", \"3.0\", \"4.0\", \"5.0+\", \"6.0+\"]\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.event_times-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.event_times","text":"outcome_times(srv::OneSidedSurv)\n\nGet times at which an event (not censoring) takes place.\n\nExamples\n\njulia> event_times(Surv([1, 2, 3], [true, false, true], :r))\n2-element Vector{Float64}:\n 1.0\n 3.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.outcome_status-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.outcome_status","text":"outcome_status(srv::OneSidedSurv)\n\nGet vector of survival indicators.\n\nExamples\n\njulia> outcome_status(Surv([1, 2, 3], [true, false, true], :r))\n3-element Vector{Bool}:\n 1\n 0\n 1\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.outcome_times","text":"outcome_times(srv::OneSidedSurv)\noutcome_times(srv::TwoSidedSurv)\n\nGet times at which an outcome (event or censoring) takes place.\n\nExamples\n\njulia> outcome_times(Surv([1, 2, 3], [true, false, true], :r))\n3-element Vector{Float64}:\n 1.0\n 2.0\n 3.0\n\njulia> outcome_times(Surv([1, 2, 3], [5, 6, 7]))\n2-element Vector{Vector{Float64}}:\n [1.0, 2.0, 3.0]\n [5.0, 6.0, 7.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.surv_stats-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.surv_stats","text":"surv_stats(srv::OneSidedSurv; events_only = false)\n\nGet set of useful summary statistics over time - if events_only = false (default) then returned for all outcomes, otherwise only return the times at which an event occurred (useful for computing non-parametric estimators).\n\nExamples\n\njulia> surv_stats(Surv([1, 2, 3], [false, true, false], :r))\n(time = [1.0, 2.0, 3.0], nrisk = [3, 2, 1], ncens = [1, 0, 1], nevents = [0, 1, 0], noutcomes = [1, 1, 1])\n\njulia> surv_stats(Surv([1, 2, 3], [false, true, false], :r); events_only = true)\n(time = [2.0], nrisk = [2], ncens = [0], nevents = [1], noutcomes = [1])\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.threshold_risk-Tuple{SurvivalAnalysis.OneSidedSurv, Number}","page":"Reference (API)","title":"SurvivalAnalysis.threshold_risk","text":"threshold_risk(srv::OneSidedSurv, p::Number)\n\nGet the time at which a given proportion of observations are no longer at risk. Useful when computing metrics and calculations become increasingly unstable as number of observations at risk decreases over time.\n\nExamples\n\n# time at which 80% of observations have experienced the event or been censored\njulia> threshold_risk(Surv([1, 2, 3, 4, 5, 6], [false, true, false, false, true, true], :r), 0.8)\n6.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.total_censored-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.total_censored","text":"total_censored(srv::OneSidedSurv)\ntotal_censored(srv::OneSidedSurv, t::Number)\n\nGet total number censored (optionally at a given time).\n\nExamples\n\njulia> total_censored(Surv([1, 2, 3], [false, true, false], :r))\n2\n\njulia> total_censored(Surv([1, 2, 3], [true, false, true], :r), 3)\n0\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.total_events-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.total_events","text":"total_events(srv::OneSidedSurv)\ntotal_events(srv::OneSidedSurv, t::Number)\n\nGet total number of events (optionally at a given time).\n\nExamples\n\njulia> total_events(Surv([1, 2, 3], [true, false, true], :r))\n2\n\njulia> total_events(Surv([1, 2, 3], [true, false, true], :r), 3)\n1\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.total_outcomes-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.total_outcomes","text":"total_outcomes(srv::OneSidedSurv)\ntotal_outcomes(srv::OneSidedSurv, t::Number)\n\nGet total number of outcomes (optionally at a given time).\n\nExamples\n\njulia> total_outcomes(Surv([1, 2, 3], [false, true, false], :r))\n3\n\njulia> total_outcomes(Surv([1, 2, 3], [true, false, true], :r), 3)\n1\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.total_risk-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.total_risk","text":"total_risk(srv::OneSidedSurv)\ntotal_risk(srv::OneSidedSurv, t::Number)\n\nGet total number at risk (optionally at a given time).\n\nExamples\n\njulia> total_risk(Surv([1, 2, 3], [false, true, false], :r))\n3\n\njulia> total_risk(Surv([1, 2, 3], [true, false, true], :r), 2)\n2\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.unique_event_times-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.unique_event_times","text":"unique_event_times(srv::OneSidedSurv)\n\nGet unique times at which an event takes place.\n\nExamples\n\njulia> unique_event_times(Surv([1, 2, 1], [true, false, true], :r))\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.unique_outcome_times-Tuple{SurvivalAnalysis.OneSidedSurv}","page":"Reference (API)","title":"SurvivalAnalysis.unique_outcome_times","text":"unique_outcome_times(srv::OneSidedSurv)\n\nGet unique times at which an outcome takes place\n\nExamples\n\njulia> unique_outcome_times(Surv([1, 2, 1], [true, false, true], :r))\n2-element Vector{Float64}:\n 1.0\n 2.0\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.Srv","page":"Reference (API)","title":"SurvivalAnalysis.Srv","text":"Srv(T::Symbol, Δ::Symbol, type::Int = 1)\n\nCreate a SurvTerm object for internal use for fitting models. Arguments, T and Δ should be a reference to the name of the time and status variables in a DataFrame respectively. type should be 1 (or omitted) for right-censoring or -1 for left-censoring.\n\nExamples\n\njulia> @formula(Srv(t, d) ~ 1) # right-censoring\nFormulaTerm\nResponse:\n  (t,d)->Srv(t, d)\nPredictors:\n  1\n\njulia> @formula(Srv(t, d, -1) ~ X) # left-censoring\nFormulaTerm\nResponse:\n  (t,d)->Srv(t, d, -1)\nPredictors:\n  X(unknown)\n\n\n\n\n\n","category":"function"},{"location":"api/#Models","page":"Reference (API)","title":"Models","text":"","category":"section"},{"location":"api/#SurvivalEstimator","page":"Reference (API)","title":"SurvivalEstimator","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"SurvivalEstimator.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#SurvivalAnalysis.KaplanMeier","page":"Reference (API)","title":"SurvivalAnalysis.KaplanMeier","text":"KaplanMeier <: SurvivalEstimator\n\nSee SurvivalEstimator.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.NelsonAalen","page":"Reference (API)","title":"SurvivalAnalysis.NelsonAalen","text":"NelsonAalen <: SurvivalEstimator\n\nSee SurvivalEstimator.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.SurvivalEstimator","page":"Reference (API)","title":"SurvivalAnalysis.SurvivalEstimator","text":"SurvivalEstimator <: StatisticalModel\n\nAbstract type for all non-parametric estimators implemented in, or extending, this package. Type 'inherits' from StatsAPI.StatisticalModel to enable formula fitting and predicting interface. Note❗This may be abstracted further into ConditionalSurvivalEstimator <: SurvivalEstimator and UnconditionalSurvivalEstimator <: SurvivalEstimator.\n\nAvailable methods:\n\nfit and predict - Fit model and make predictions from fitted model with @formula or matrix interface, see Fitting and predicting\nconfint - Calculate confidence intervals around estimates\ntime - Extract fitted times\nsurvival - Extract estimated survival probabilities\nstd - Extract computed standard deviation\ndistr - Extract fitted survival distribution\n\nObjects inheriting from this should have the following fields:\n\ntime::Vector{Float64} - Fitted survival times\nsurvival::Vector{Float64} - Estimated survival probabilities\nstd::Vector{Float64} - Computed standard deviation\ndistr::DiscreteNonParametric - Fitted survival distribution\nstats::NamedTuple - Summary statistics such as numbers at risk, dead, censored\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.Libc.time-Tuple{SurvivalEstimator}","page":"Reference (API)","title":"Base.Libc.time","text":"time(npe::SurvivalEstimator)\ntime(npe::StatsModels.TableStatisticalModel{<:SurvivalEstimator, <:AbstractMatrix})\n\nReturn fitted times from a SurvivalEstimator.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> time(km(@formula(Srv(Y, D) ~ 1), data))\n4-element Vector{Float64}:\n 1.0\n 4.0\n 5.0\n 8.0\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.std-Tuple{SurvivalEstimator}","page":"Reference (API)","title":"Statistics.std","text":"std(npe::SurvivalEstimator)\nstd(npe::StatsModels.TableStatisticalModel{<:SurvivalEstimator, <:AbstractMatrix})\n\nReturn computed standard deviation from a SurvivalEstimator.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> std(km(@formula(Srv(Y, D) ~ 1), data))\n4-element Vector{Float64}:\n 1.0004625991132958\n 0.712458742539604\n 0.6082063644330836\n 0.5713145523891875\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Tuple{KaplanMeier, Number}","page":"Reference (API)","title":"StatsAPI.confint","text":"confint(km::KaplanMeier; level::Float64 = 0.95)\nconfint(km::KaplanMeier, t::Number; level::Float64 = 0.95)\n\nCalculate the confidence interval (CI) around a fitted Kaplan-Meier estimate to level% confidence. If t provided then returns CI at that time, otherwise returns CI at all fitted times. Standard deviation is calculated using the pointwise method of Kalbfleisch and Prentice (1980).\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> confint(km(@formula(Srv(Y, D) ~ 1), data))\n4-element Vector{Tuple{Float64, Float64}}:\n (0.473009271362049, 0.9852813933673431)\n (0.38088152320549545, 0.9425909522237038)\n (0.21830025822743343, 0.8691223292427415)\n (0.0700802713627666, 0.7534316354804488)\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.confint-Tuple{NelsonAalen, Number}","page":"Reference (API)","title":"StatsAPI.confint","text":"confint(na::NelsonAalen; level::Float64 = 0.95)\nconfint(na::NelsonAalen, t::Number; level::Float64 = 0.95)\n\nCalculate the confidence interval (CI) around a fitted Nelson-Aalen estimate to level% confidence. If t provided then returns CI at that time, otherwise returns CI at all fitted times.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> confint(na(@formula(Srv(Y, D) ~ 1), data), 10)\n(0.23186692958834798, 0.9464141496254767)\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit-Tuple{Type{var\"#s33\"} where var\"#s33\"<:SurvivalEstimator, AbstractMatrix{var\"#s32\"} where var\"#s32\"<:Real, SurvivalAnalysis.RCSurv}","page":"Reference (API)","title":"StatsAPI.fit","text":"fit(obj::Type{<:SurvivalEstimator}, X::AbstractMatrix{<:Real}, Y::RCSurv)\nfit(obj::Type{<:SurvivalEstimator}, Y::RCSurv)\n\nFit a SurvivalEstimator survival model using matrix interface. It is recommended to use kaplan_meier or nelson_aalen directly instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{SurvivalEstimator, DataFrame}","page":"Reference (API)","title":"StatsAPI.predict","text":"predict(fit::SurvivalEstimator, X::AbstractMatrix{<:Real})\npredict(fit::StatsModels.TableStatisticalModel{SurvivalEstimator, Matrix{Float64}},\n    data::DataFrames.DataFrame)\n\nMake predictions from a fitted SurvivalEstimator model. See Fitting and predicting and examples below for predicting interfaces, we recommend using predict(fit, data::DataFrame).\n\nTwo prediction types can be made from a non-parametric estimator:\n\ndistr - See kaplan_meier or nelson_aalen for formulae\nsurvival_matrix - Matrix of survival probabilities\n\nPredicted distributions are returned as Distributions.DiscreteNonParametric.\n\nFunction returns a SurvivalPrediction struct.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> f = km(@formula(Srv(Y, D) ~ 1), data);\n\njulia> predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.distr-Tuple{SurvivalEstimator}","page":"Reference (API)","title":"SurvivalAnalysis.distr","text":"distr(npe::SurvivalEstimator)\ndistr(npe::StatsModels.TableStatisticalModel{<:SurvivalEstimator, <:AbstractMatrix})\n\nReturn estimated survival distribution from a SurvivalEstimator.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> distr(km(@formula(Srv(Y, D) ~ 1), data))\nDiscreteNonParametric{Float64, Float64, Vector{Float64}, Vector{Float64}}(\nsupport: [0.0, 1.0, 4.0, 5.0, 8.0]\np: [0.0, 0.11250000000000004, 0.15749999999999997, 0.20999999999999996]\n)\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.kaplan_meier-Tuple","page":"Reference (API)","title":"SurvivalAnalysis.kaplan_meier","text":"kaplan_meier(Y::RCSurv)\nkaplan_meier(f::@formula, data::DataFrames.DataFrame)\nkaplan_meier(X::AbstractMatrix{<:Real}, Y::RCSurv)\nfit(KaplanMeier, X::AbstractMatrix{<:Real}, Y::RCSurv)\n\nAliases: km, kaplan\n\nFit a non-parametric Kaplan-Meier estimator on a right-censored survival outcome. See Fitting and predicting and examples below for fitting interfaces, we recommend using kaplan_meier(::@formula...) (or aliases).\n\nThe Kaplan-Meier Estimator is defined by\n\nS(τ) = _itᵢτ (1 - fracdᵢnᵢ)\n\nwhere dᵢ and nᵢ are the number of events and nunber at risk at time tᵢ respectively.\n\nStandard deviation is calculated using the pointwise method of Kalbfleisch and Prentice (1980).\n\nFuture additions:\n\nSupport for other censoring types (see #46)\nSupport for stratified estimator (see #47)\n\nFunction returns a KaplanMeier struct.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> f = kaplan_meier(@formula(Srv(Y, D) ~ 1), data)\nStatsModels.TableStatisticalModel{KaplanMeier, Matrix{Float64}}\n\n(Y,D;+) ~ 1\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.nelson_aalen-Tuple","page":"Reference (API)","title":"SurvivalAnalysis.nelson_aalen","text":"nelson_aalen(Y::RCSurv)\nnelson_aalen(f::@formula, data::DataFrames.DataFrame)\nnelson_aalen(X::AbstractMatrix{<:Real}, Y::RCSurv)\nfit(NelsonAalen, X::AbstractMatrix{<:Real}, Y::RCSurv)\n\nAliases: na, nelson\n\nFit a non-parametric Nelson-NelsonAalen estimator on a right-censored survival outcome. See Fitting and predicting and examples below for fitting interfaces, we recommend using nelson_aalen(::@formula...) (or aliases).\n\nThe Nelson-Aalen Estimator is defined by\n\nH(τ) = _itᵢτ fracdᵢnᵢ\n\nwhere dᵢ and nᵢ are the number of events and nunber at risk at time tᵢ respectively and Ĥ is the estimated cumulative hazard function. The survival function is then Ŝ = exp(-Ĥ).\n\nFuture additions:\n\nSupport for other censoring types (see #46)\nSupport for stratified estimator (see #47)\n\nFunction returns a NelsonAalen struct.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> f = nelson_aalen(@formula(Srv(Y, D) ~ 1), data)\nStatsModels.TableStatisticalModel{NelsonAalen, Matrix{Float64}}\n\n(Y,D;+) ~ 1\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.survival-Tuple{SurvivalEstimator}","page":"Reference (API)","title":"SurvivalAnalysis.survival","text":"survival(npe::SurvivalEstimator)\nsurvival(npe::StatsModels.TableStatisticalModel{<:SurvivalEstimator, <:AbstractMatrix})\n\nReturn fitted survival probabilities from a SurvivalEstimator.\n\nExamples\n\njulia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false]);\n\njulia> survival(km(@formula(Srv(Y, D) ~ 1), data))\n4-element Vector{Float64}:\n 0.9\n 0.7875\n 0.63\n 0.42000000000000004\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalModel","page":"Reference (API)","title":"SurvivalModel","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"SurvivalModel.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#SurvivalAnalysis.SurvivalModel","page":"Reference (API)","title":"SurvivalAnalysis.SurvivalModel","text":"SurvivalModel <: StatisticalModel\n\nAbstract type for all models implemented in, or extending, this package. Type 'inherits' from StatsAPI.StatisticalModel to enable formula fitting and predicting interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#ParametricSurvival","page":"Reference (API)","title":"ParametricSurvival","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"ParametricSurvival.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#SurvivalAnalysis.ParametricAFT","page":"Reference (API)","title":"SurvivalAnalysis.ParametricAFT","text":"ParametricAFT{<:ContinuousUnivariateDistribution} <: ParametricSurvival\n\nSee ParametricSurvival.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.ParametricPH","page":"Reference (API)","title":"SurvivalAnalysis.ParametricPH","text":"ParametricPH{<:ContinuousUnivariateDistribution} <: ParametricSurvival\n\nSee ParametricSurvival.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.ParametricSurvival","page":"Reference (API)","title":"SurvivalAnalysis.ParametricSurvival","text":"ParametricSurvival <: SurvivalModel\n\nAbstract type for all fully-parametric survival models implemented in, or extending, this package. Type 'inherits' SurvivalModel.\n\nAvailable methods:\n\ncoef - Extract fitted coefficients\nfit and predict - Fit model and make predictions from fitted model with @formula or matrix interface, see Fitting and predicting\nbaseline - Extract fitted baseline distribution, see ph and aft for more\nscale - Extract scale parameter of fitted distribution\n\nAll distributions are fitted with the Kalbfleisch-Prentice parametrisation and then converted as required to make use of Distributions.jl\n\nObjects inheriting from this should have the following fields:\n\ncoefficients::Vector{Float64} - Fitted coefficients\nscale::Float64 - Fitted scale parameter for baseline distribution before transformation\nhessian::Matrix - Hessian from Optim\nvar_cov::Matrix - Covariance matrix\ntstats::Vector - t-statistics\nbaseline<:ContinuousUnivariateDistribution - Fitted baseline distribution\nroutine - Optimisation routine from Optim\n\n\n\n\n\n","category":"type"},{"location":"api/#Distributions.scale-Tuple{StatsModels.TableStatisticalModel{var\"#s33\", var\"#s32\"} where {var\"#s33\"<:ParametricSurvival, var\"#s32\"<:(AbstractMatrix{T} where T)}}","page":"Reference (API)","title":"Distributions.scale","text":"scale(mm::StatsModels.TableStatisticalModel{<:ParametricSurvival, <:AbstractMatrix})\nscale(mm::ParametricSurvival)\n\nExtract estimated scale parameter (before transformation) for baseline distribution from fitted ParametricSurvival object.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit-Tuple{Type{var\"#s21\"} where var\"#s21\"<:ParametricSurvival, AbstractMatrix{var\"#s16\"} where var\"#s16\"<:Real, SurvivalAnalysis.RCSurv, Type{var\"#s2\"} where var\"#s2\"<:Distribution{Univariate, Continuous}}","page":"Reference (API)","title":"StatsAPI.fit","text":"fit(t::Type{<:ParametricSurvival}, X::AbstractMatrix{<:Real}, Y::RCSurv,\n    d::Type{<:ContinuousUnivariateDistribution}; init::Number = 1)\n\nFit a ParametricSurvival survival model using matrix interface. It is recommended to use ph or aft directly instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{ParametricAFT, AbstractMatrix{var\"#s49\"} where var\"#s49\"<:Real}","page":"Reference (API)","title":"StatsAPI.predict","text":"predict(fit::ParametricAFT, X::AbstractMatrix{<:Real})\npredict(fit::StatsModels.TableStatisticalModel{ParametricAFT, Matrix{Float64}},\n    data::DataFrames.DataFrame)\n\nMake predictions from a fitted ParametricAFT model. See Fitting and predicting and examples below for predicting interfaces, we recommend using predict(fit, data::DataFrame).\n\nThree prediction types can be made from a fitted AFT model:\n\nlp - Xβ\ncrank - -Xβ\ndistr - F(t) = F₀(texp(Xβ))\n\nwhere β are estimated coefficients, X are covariates from the new data, and F₀ is the estimated baseline distribution CDF function. Predicted distributions are returned as ContinuousAFTDistribution <: Distributions.ContinuousUnivariateDistribution.\n\nNote❗The AFT model assumes that a higher linear predictor means a lower risk of event and therefore a higher survival time, i.e., βXᵢ  βXⱼ  hᵢ(t)  hⱼ(t) - hence crank = -lp.\n\nFuture updates will add transformation methods for more prediction types (see #12).\n\nFunction returns a SurvivalPrediction struct.\n\nExamples\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = aft(@formula(Srv(Y, D) ~ X), data, Exponential);\n\njulia> predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{ParametricPH, AbstractMatrix{var\"#s49\"} where var\"#s49\"<:Real}","page":"Reference (API)","title":"StatsAPI.predict","text":"predict(fit::ParametricPH, X::AbstractMatrix{<:Real})\npredict(fit::StatsModels.TableStatisticalModel{ParametricPH, Matrix{Float64}},\n    data::DataFrames.DataFrame)\n\nMake predictions from a fitted ParametricPH model. See Fitting and predicting and examples below for predicting interfaces, we recommend using predict(fit, data::DataFrame).\n\nThree prediction types can be made from a fitted PH model:\n\nlp - Xβ\ncrank - Xβ\ndistr - F(t) = 1 - S₀(t)^exp(Xβ)\n\nwhere β are estimated coefficients, X are covariates from the new data, and S₀ is the estimated baseline distribution survival function. Predicted distributions are returned as ContinuousPHDistribution <: Distributions.ContinuousUnivariateDistribution.\n\nNote❗The PH model assumes that a higher linear predictor means a higher risk of event and therefore a lower survival time, i.e., `βXᵢ > βXⱼ → hᵢ(t) > hⱼ(t) - hence crank = lp. This means when calculating concordance you must include rev = true.\n\nFuture updates will add transformation methods for more prediction types (see #12).\n\nFunction returns a SurvivalPrediction struct.\n\nExamples\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = ph(@formula(Srv(Y, D) ~ X), data, Weibull);\n\njulia> predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.aft-Tuple","page":"Reference (API)","title":"SurvivalAnalysis.aft","text":"aft(f::@formula, data::DataFrames.DataFrame, d::Type{T}; init::Number = 1)\naft(X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\nfit(ParametricAFT, X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\n\nFit a fully-parametric accelerated failure time (AFT) model with baseline distribution d. See Fitting and predicting and examples below for fitting interfaces, we recommend using aft(::@formula...).\n\nFully-parametric AFT models are defined by\n\nh(t) = e^-Xβ h₀(t e^-Xβ)\n\nwhere β are coefficients to be estimated, X are covariates, and h₀ is the hazard function of an assumed baseline distribution, d. Available choices for distributions are:\n\nDistributions.Exponential\nDistributions.Weibull\n\nAFT models assumes that an increase in a covariate results in an acceleration of the event by a constant. This is best explained by example. The above formula can also be expressed as S(t) = S₀(exp(-η)t) then let ηᵢ = log(2) and ηⱼ = log(1) so ηᵢ  ηⱼ. Then Sᵢ(t) = S₀(0.5t) and Sⱼ(t) = S₀(t) and so for all t, Sᵢ(t)  Sⱼ(t) as S is a decreasing function.\n\nFuture additions:\n\nMore baseline distributions (see #15)\n\nFunction returns a ParametricAFT struct.\n\nExamples\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,2,4,1,0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = aft(@formula(Srv(Y, D) ~ X), data, Weibull)\nStatsModels.TableStatisticalModel{ParametricAFT{Weibull}, Matrix{Float64}}\n\n(Y,D;+) ~ 1 + X\n\nDistr:\nWeibull{Float64}(α=1.491407, θ=11.636424)\n\nCoefficients:\n  (Scale)  (Intercept)           X\n 0.670508      2.45414  -0.0209422\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.baseline-Tuple{StatsModels.TableStatisticalModel{var\"#s33\", var\"#s32\"} where {var\"#s33\"<:ParametricSurvival, var\"#s32\"<:(AbstractMatrix{T} where T)}}","page":"Reference (API)","title":"SurvivalAnalysis.baseline","text":"baseline(mm::StatsModels.TableStatisticalModel{<:ParametricSurvival, <:AbstractMatrix})\nbaseline(mm::ParametricSurvival)\n\nExtract baseline distribution from fitted ParametricSurvival object.\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.ph-Tuple","page":"Reference (API)","title":"SurvivalAnalysis.ph","text":"ph(f::@formula, data::DataFrames.DataFrame, d::Type{T}; init::Number = 1)\nph(X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\nfit(ParametricPH, X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\n\nFit a fully-parametric proportional hazards (PH) model with baseline distribution d. See Fitting and predicting and examples below for fitting interfaces, we recommend using ph(::@formula...).\n\nFully-parametric PH models are defined by\n\nh(t) = h₀(t)exp(Xβ)\n\nwhere β are coefficients to be estimated, X are covariates, and h₀ is the hazard function of an assumed baseline distribution, d. Available choices for distributions are:\n\nDistributions.Exponential\nDistributions.Weibull\n\nNo other distributions have the PH assumption, which assumes that the risk of an event taking place is constant over time.\n\nFuture additions:\n\nMethods for testing if the assumption is valid for your data (see #11).\nMethods to calculate hazards ratios and add to show (see #40).\n\nFunction returns a ParametricPH struct.\n\nExamples\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = ph(@formula(Srv(Y, D) ~ X), data, Exponential)\nStatsModels.TableStatisticalModel{ParametricPH{Exponential}, Matrix{Float64}}\n\n(Y,D;+) ~ 1 + X\n\nDistr:\nExponential{Float64}(θ=17.121273)\n\nCoefficients:\n (Scale)  (Intercept)          X\n     1.0     -2.84032  0.0101247\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalPrediction","page":"Reference (API)","title":"SurvivalPrediction","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"SurvivalPrediction.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#SurvivalAnalysis.SurvivalPrediction-Union{Tuple{}, Tuple{T}} where T<:Number","page":"Reference (API)","title":"SurvivalAnalysis.SurvivalPrediction","text":"SurvivalPrediction(;\n    distr::Union{Nothing, Vector{<:Distribution}} = nothing,\n    lp::Union{Nothing, Vector{T}}  = nothing,\n    crank::Union{Nothing, Vector{T}} = nothing,\n    time::Union{Nothing, Vector{T}} = nothing,\n    fit_times::Union{Nothing, Vector{T}} = nothing,\n    survival_matrix::Union{Matrix{T}, Nothing} = nothing\n    ) where {T<:Number}\n\nSurvival models can make multiple types of predictions including:\n\ndistr - A survival time distribution (implemented with Distributions.jl)\nlp - A linear predictor (usually Xβ, i.e. covariates * fitted coefficients)\ncrank - A generic continuous relative risk ranking\ntime - A survival time\nsurvival_matrix - A matrix of predicted survival probabilities where rows are\n\nobservations and columns are fitted survival times corresponding to fit_times.\n\nThese predictions can only exist in a finite number of combinations so they are aggregated in types within this package (and automatically determined within this function):\n\nDeterministicSurvivalPrediction(lp, crank, time)\nDiscreteSurvivalPrediction(distr, lp, crank, time, survival_matrix)\nContinuousSurvivalPrediction(distr, lp, crank, time)\n\nAbsolutely no transformations take require assumptions take place within this function but it does transform survival_matrix to a Distributions.DiscreteNonParametric and vice versa.\n\nExamples\n\njulia> SurvivalPrediction(time = randn(5)); # DeterministicSurvivalPrediction\n\njulia> SurvivalPrediction(fit_times = randn(5), survival_matrix = randn((2, 5))); # DiscreteSurvivalPrediction\n\njulia> SurvivalPrediction(distr = fill(Exponential(), 2)); # ContinuousSurvivalPrediction\n\n\n\n\n\n","category":"method"},{"location":"api/#Measures","page":"Reference (API)","title":"Measures","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"SurvivalMeasure.jl\", \"SurvivalTimeMeasure.jl\", \"concordance.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#SurvivalAnalysis.SurvivalMeasure","page":"Reference (API)","title":"SurvivalAnalysis.SurvivalMeasure","text":"SurvivalMeasure\n\nAbstract type for all measures implemented in, or extending, this package.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.MAE-Tuple{SurvivalAnalysis.OneSidedSurv, Vector{var\"#s49\"} where var\"#s49\"<:Number}","page":"Reference (API)","title":"SurvivalAnalysis.MAE","text":"MAE(truth::OneSidedSurv, prediction::Vector{<:Number})\n\nCalculates the Mean Absolute Error (MAE), defined by\n\nMAEᵢ = δᵢtᵢ - tᵢ \nmean = frac1m ᵢ MAEᵢ \nse = fracσm\n\nwhere t is the true survival time, t̂ is the predicted survival time, δ is the censoring indicator, m = ᵢ δᵢ, and σ is the sample standard deviation of MAE.\n\nReturns a MAE struct inheriting from SurvivalTimeMeasure.\n\nNote❗Censored observations in the test set are ignored.\n\nExamples\n\njulia> truth = Surv([1, 4, 2, 2, 8], [true, false, false, true, false], :r);\n\njulia> pred = [pi, sqrt(3), 1, 8, 9];\n\njulia> MAE(truth, pred)\nMAE = 4.0708 (σ = 1.9292)\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.MSE-Tuple{SurvivalAnalysis.OneSidedSurv, Vector{var\"#s49\"} where var\"#s49\"<:Number}","page":"Reference (API)","title":"SurvivalAnalysis.MSE","text":"MSE(truth::OneSidedSurv, prediction::Vector{<:Number})\n\nCalculates the Mean Squared Error (MSE), defined by\n\nMSEᵢ = δᵢ(tᵢ - tᵢ)^2 \nmean = frac1m ᵢ MSEᵢ \nse = fracσm\n\nwhere t is the true survival time, t̂ is the predicted survival time, δ is the censoring indicator, m = ᵢ δᵢ, and σ is the sample standard deviation of MSE.\n\nReturns a MSE struct inheriting from SurvivalTimeMeasure.\n\nNote❗Censored observations in the test set are ignored.\n\nExamples\n\njulia> truth = Surv([1, 4, 2, 2, 8], [true, false, false, true, false], :r);\n\njulia> pred = [pi, sqrt(3), 1, 8, 9];\n\njulia> MSE(truth, pred)\nMSE = 20.2932 (σ = 15.7068)\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.RMSE-Tuple{SurvivalAnalysis.OneSidedSurv, Vector{var\"#s49\"} where var\"#s49\"<:Number}","page":"Reference (API)","title":"SurvivalAnalysis.RMSE","text":"RMSE(truth::OneSidedSurv, prediction::Vector{<:Number})\n\nCalculates the Root Mean Squared Error (RMSE), defined by\n\nMSEᵢ = δᵢ(tᵢ - tᵢ)^2 \nRMSE = sqrtfrac1m ᵢ MSEᵢ \nse = σ(2m * rmse)\n\nwhere t is the true survival time, t̂ is the predicted survival time, δ is the censoring indicator, m = ᵢ δᵢ, and σ is the sample standard deviation of MSE.\n\nReturns a RMSE struct inheriting from SurvivalTimeMeasure.\n\nNote❗Censored observations in the test set are ignored. Note❗RMSE is an aggregated measure which means losses actually correspond to MSEᵢ.\n\nExamples\n\njulia> truth = Surv([1, 4, 2, 2, 8], [true, false, false, true, false], :r);\n\njulia> pred = [pi, sqrt(3), 1, 8, 9];\n\njulia> RMSE(truth, pred)\nRMSE = 4.5048 (σ = 1.7433)\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.SurvivalTimeMeasure","page":"Reference (API)","title":"SurvivalAnalysis.SurvivalTimeMeasure","text":"SurvivalTimeMeasure\n\nAbstract type for all survival time measures implemented in, or extending, this package. A survival time measure is any measure of the form L(t t) where t is the observed event time for an observation and t̂ is a prediction of the survival time.\n\nNote❗Survival time measures are poorly researched in the literature and no good studies demonstrate their utility. Nor is there concensus on the 'right' way to implement these. Here the measures remove all censored observations and then compare predicted survival times for uncensored observations. Alternatives could include: using an IPCW weighting method, or retaining censoring observations and applying an uncertainty penalty.\n\nFields\n\nStructs inheriting from this type include the following fields\n\nlosses - Pointwise losses for the measure, i.e. L(tᵢ tᵢ)\nmean - Aggregation of losses, usually the sample mean\nse - Standard error of the mean\n\nNote❗ RMSE is an aggregated measure which means mean is not simply the sample mean over the losses and instead mean is just used as a shorthand.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.ConcordanceWeights","page":"Reference (API)","title":"SurvivalAnalysis.ConcordanceWeights","text":"ConcordanceWeights(S::Int8, G::Int8, tied_preds::Float64 tied_times::Float64)\n\nWeights used in the concordance function. S and G reflect the power applied to the Kaplan-Meier estimates of the survival and censoring distributions of the fitted data used to apply weighting at a given time. For example ConcordanceWeights(1, -2, 0.5, 0.5) will tell the concordance function to multiply concordant pairs at time t by S(t)/G(t)². tied_preds and tied_times determine how to handle ties in predictions and observed times respectively.\n\nSee concordance for full examples.\n\nNote❗It is strongly recommended that S ≥ 0 and G ≤ 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.concordance","page":"Reference (API)","title":"SurvivalAnalysis.concordance","text":"concordance(\n    truth::OneSidedSurv, prediction::Vector{<:Number}, weights::Union{Symbol, ConcordanceWeights};\n    tied_preds=0.5, tied_times=0, cutoff=nothing, train::OneSidedSurv=nothing, rev=false\n)\n\nAliases: cindex\n\nGeneric function to call any concordance index method. Concordance is a measure of discrimination which evaluates if a prediction is concordant with the truth, i.e. let Tᵢ,Tⱼ be the true survival times, truth, for observations i and j and let  ϕᵢ, ϕⱼ be predictions, prediction, then these are concordant if ϕᵢ  ϕⱼ  Tᵢ  Tⱼ.\n\nIn survival analysis the generic C-index is defined as follows\n\nC = fracsum_ij W(tᵢ)I(tᵢ  tⱼ yᵢ  yⱼ tᵢ  τ)δᵢW(tᵢ)I(tᵢ  tⱼ tᵢ  τ)δᵢ\n\nwhere tᵢ,tⱼ are true survival times, yᵢ,yⱼ are predictions, τ is a cutoff time used to ensure stability even when censoring is high, δᵢ is the censoring indicator and W is a weighting function determined by weights as follows:\n\n:I or :Harrell - Harrell's C - W(tᵢ) = 1\n:G2 or :Uno - Uno's C - W(tᵢ) = 1G(tᵢ)\n:SG or :Schemper - Schemper's C - W(tᵢ) = S(tᵢ)G(tᵢ)\n:S or :Peto - Peto-Wilcoxon's C - W(tᵢ) = S(tᵢ)\n\nwhere S(tᵢ) and G(tᵢ) are respectively the Kaplan-Meier estimates of the survival and censoring distributions of the training data at time tᵢ. For any other combination of weights pass a ConcordanceWeights object to weights. Note❗If training data is not provided to train then truth is used to estimate S and G but it is strongly recommended to provide the training data if possibe.\n\nWe also include an implementation of Gönen-Heller's C with weights = :GH or :Gonen. Note❗This is actually a very different method from the others and calculates concordance for predictions from a Cox PH model only. We may move this to its own function in the future to avoid misuse.\n\nThere is open debate about how to handle ties when calculating the concordance. Ties can occur in predictions and in the observed survival times. The defaults here tied_preds=0.5 and tied_times=0 are set as these seem to be the most common but they can be changed. Note❗If you pass a ConcordanceWeights object then the tied weights specified in this will take priority.\n\nNote❗For predictions from PH models or any model where the prediction represents a relative risk then a higher value of ϕ implies a higher risk of event which will result in a lower survival time. In this case a prediction is concordant with the survival time if ϕᵢ  ϕⱼ  Tᵢ  Tⱼ. To do this within the function just set rev=true.\n\nExamples\n\njulia> T = [1.0,0.1,pi,0.9,0.4,20,1,5,9,2.5];\n\njulia> ϕ = [0.1,0.2,0.1,0.9,0.25,exp(2),8,log(9),2,8];\n\njulia> Δ = [true,true,false,true,true,false,true,false,true,true];\n\njulia> Y = Surv(T, Δ, :r);\n\njulia> train = Surv([3,3,9,12,2,1,8,4,10,8], Δ, :r);\n\njulia> concordance(Y, ϕ, cutoff = threshold_risk(Y, 0.8)) # Harrell's C cutoff when 80% data is censored or dead\nSurvivalAnalysis.Concordance\n\nHarrell's C = 0.6153846153846154\n\nCutoff: T ≤ 9.0\nCounts:\n Pairs  Comparable  Concordant  Disconcordant\n    90          39          23             14\nWeights:\n IPCW  Tied preds  Tied times\n    1         0.5         0.0\nTies:\n Times  Preds  Both\n     1      2     0\nWeighted calculation:\n Numerator  Denominator         C\n      24.0         39.0  0.615385\n\njulia> concordance(Y, ϕ, :Uno, train=train) # Uno's C\nSurvivalAnalysis.Concordance\n\nUno's C = 0.6221374045801525\n\nCutoff: T ≤ 20.0\nCounts:\n Pairs  Comparable  Concordant  Disconcordant\n    90          39          23             14\nWeights:\n IPCW  Tied preds  Tied times\n 1/G²         0.5         0.0\nTies:\n Times  Preds  Both\n     1      2     0\nWeighted calculation:\n Numerator  Denominator         C\n   28.1728       45.284  0.622137\n\njulia> cindex(Y, ϕ, ConcordanceWeights(5, -3, 0.5, 0.5, \"Silly Weights\"); train=train) # Custom weights\nSurvivalAnalysis.Concordance\n\nSilly Weights C = 0.6070334788405888\n\nCutoff: T ≤ 20.0\nCounts:\n Pairs  Comparable  Concordant  Disconcordant\n    90          40          23             14\nWeights:\n  IPCW  Tied preds  Tied times\n S⁵/G³         0.5         0.5\nTies:\n Times  Preds  Both\n     1      2     0\nWeighted calculation:\n Numerator  Denominator         C\n   25.6265       42.216  0.607033\n\n\n\n\n\n","category":"function"},{"location":"api/#Plotting","page":"Reference (API)","title":"Plotting","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"plots.jl\"]","category":"page"},{"location":"api/#RecipesBase.apply_recipe","page":"Reference (API)","title":"RecipesBase.apply_recipe","text":"plot(npe::SurvivalEstimator, plot_confint::Bool = true; level = 0.95)\nplot(npe::StatsModels.TableStatisticalModel{SurvivalEstimator, Matrix{Float64}},\n    plot_confint::Bool = true; level = 0.95)\n\nRecipe for plotting fitted non-parametric estimators, npe. If plot_confint then confidence intervals also plotted at a level% confidence level.\n\nExamples\n\njulia> using Plots\n\njulia> data = DataFrame(t = randn(10), d = [trues(5)..., falses(5)...]);\n\njulia> plot(kaplan_meier(@formula(Srv(t, d) ~ 1), data));\n\njulia> plot(nelson_aalen(@formula(Srv(t, d) ~ 1), data).model);\n\n\n\n\n\n","category":"function"},{"location":"api/#Tools","page":"Reference (API)","title":"Tools","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"Modules = [SurvivalAnalysis]\nPages   = [\"tools.jl\"]\nOrder   = [:type, :function]","category":"page"},{"location":"api/#SurvivalAnalysis.cum_hazard-Tuple{UnivariateDistribution{S} where S<:ValueSupport, Real}","page":"Reference (API)","title":"SurvivalAnalysis.cum_hazard","text":"cum_hazard(d::UnivariateDistribution, x::Real)\n\nAliases: Hₜ\n\nCompute the cumulative hazard function of distribution d at point x.\n\nThe cumulative hazard function for random variable t is defined as\n\nH_t(x) = int^x_0 h_t(u) du = -log(S_t(x))\n\nwhere hₜ is the hazard function of t and Sₜ is the survival function of t.\n\nExamples\n\njulia> using Distributions\n\njulia> cum_hazard(Binomial(5, 0.5), 3)\n1.6739764335716711\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.hazard-Tuple{UnivariateDistribution{S} where S<:ValueSupport, Real}","page":"Reference (API)","title":"SurvivalAnalysis.hazard","text":"hazard(d::UnivariateDistribution, x::Real)\n\nAliases: hₜ\n\nCompute the hazard function of distribution d at point x.\n\nThe hazard function for random variable t is defined as\n\nh_t(x) = fracf_t(x)S_t(x)\n\nwhere fₜ is the pdf of t and Sₜ is the survival function of t.\n\nExamples\n\njulia> using Distributions\n\njulia> hazard(Binomial(5, 0.5), 3)\n1.6666666666666679\n\n\n\n\n\n","category":"method"},{"location":"api/#Index","page":"Reference (API)","title":"Index","text":"","category":"section"},{"location":"api/","page":"Reference (API)","title":"Reference (API)","text":"","category":"page"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials","title":"Tutorials","text":"Coming soon...","category":"page"},{"location":"explanations/#Explanations","page":"Explanations","title":"Explanations","text":"","category":"section"},{"location":"explanations/","page":"Explanations","title":"Explanations","text":"Coming soon...","category":"page"},{"location":"news/#v0.1.0","page":"Changelog","title":"v0.1.0","text":"","category":"section"},{"location":"news/","page":"Changelog","title":"Changelog","text":"Initial release","category":"page"},{"location":"#SurvivalAnalysis.jl-Manual","page":"Home","title":"SurvivalAnalysis.jl Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Survival analysis in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the latest version from JuliaRegistries with","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"SurvivalAnalysis\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or install the latest stable version from GitHub with","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(url=\"https://github.com/RaphaelS1/SurvivalAnalysis.jl.git\")","category":"page"},{"location":"#Using-this-manual-Diátaxis","page":"Home","title":"Using this manual - Diátaxis","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Throughout this package we have tried to adhere to the Diátaxis documentation style. This means clearly separating:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials - Learning-oriented lessons guiding reader through steps required to complete a project.\nHow-to guides - Goal-oriented directions taking reader through steps required to solve a real-world problem.\nExplanations - Understanding-oriented discussion to clarify and illuminate a particular topic.\nReference (API) - Information-oriented technical descriptions of the software and how to operate it.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Diataxis)","category":"page"},{"location":"","page":"Home","title":"Home","text":"As well as having specific pages for these areas, we will also aim to include some element of 'explanation' and 'how-to' into the function and and type reference documentation were sensible.","category":"page"},{"location":"#Package-features","page":"Home","title":"Package features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Kaplan Meier estimator (+plotting)\nNelson Aalen estimator (+plotting)\nParametric PH models (Exponential and Weibull)\nParametric AFT models (Exponential and Weibull)\nDiscrete and continuous survival prediction objects, including distribution, linear predictor and general risk return types\nPlotting for non parametric estimators\nSurv object for unified censoring indicator (functionality for left, right, interval)\nExtended formula interface for survival objects","category":"page"},{"location":"#Upcoming-features","page":"Home","title":"Upcoming features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CoxPH\nLog-rank tests\nResiduals (Schoenfeld etc.)\nPredict type transformations\nGeneric plotting functionality\nProportional odds functionality\nMore parametric AFTS\nAnalytical optimisation\nDiscrimination measures\nScoring rules\nCalibration measures\nBayesian interface\nmlr3proba integration\nMLJ integration\nDocumentation","category":"page"}]
}
