var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup = quote\n    using DataFrames, Distributions, SurvivalAnalysis\nend","category":"page"},{"location":"api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SurvivalAnalysis]\nOrder   = [:module]","category":"page"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SurvivalAnalysis]\nOrder   = [:type]","category":"page"},{"location":"api/#SurvivalAnalysis.ConcordanceWeights","page":"API","title":"SurvivalAnalysis.ConcordanceWeights","text":"ConcordanceWeights(S::Int8, G::Int8, tied_preds::Float64 tied_times::Float64)\n\nWeights used in the concordance function. S and G reflect the power applied to the Kaplan-Meier estimates of the survival and censoring distributions of the fitted data used to apply weighting at a given time. For example ConcordanceWeights(1, -2, 0.5, 0.5) will tell the concordance function to multiply concordant pairs at time t by S(t)/G(t)². tied_preds and tied_times determine how to handle ties in predictions and observed times respectively.\n\nSee concordance for full examples.\n\nNote❗  It is strongly recommended that S ≥ 0 and G ≤ 0.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.ParametricAFT","page":"API","title":"SurvivalAnalysis.ParametricAFT","text":"ParametricAFT{<:ContinuousUnivariateDistribution} <: ParametricSurvival\n\nSee ParametricSurvival.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.ParametricPH","page":"API","title":"SurvivalAnalysis.ParametricPH","text":"ParametricPH{<:ContinuousUnivariateDistribution} <: ParametricSurvival\n\nSee ParametricSurvival.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.ParametricSurvival","page":"API","title":"SurvivalAnalysis.ParametricSurvival","text":"ParametricSurvival <: SurvivalModel\n\nAbstract type for all fully-parametric survival models implemented in, or extending, this package. Type 'inherits' SurvivalModel. Available methods\n\ncoef - Extract fitted coefficients\nfit and predict - Fit model and make predictions from fitted model with @formula or\n\nmatrix interface, see How to fit and predict\n\nbaseline - Extract fitted baseline distribution, see ph and aft for more\nscale - Extract scale parameter of fitted distribution\n\nAll distributions are fitted with the Kalbfleisch-Prentice parametrisation and then converted as required to make use of Distributions.jl\n\nObjects inheriting from this should have the following fields\n\ncoefficients::Vector{Float64} - Fitted coefficients\nscale::Float64 - Fitted scale parameter for baseline distribution before transformation\nhessian::Matrix - Hessian from Optim\nvar_cov::Matrix - Covariance matrix\ntstats::Vector - t-statistics\nbaseline<:ContinuousUnivariateDistribution - Fitted baseline distribution\nroutine - Optimisation routine from Optim\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.Surv-Tuple{Union{Vector{T}, T} where T<:Number, Union{Vector{T}, T} where T<:Number}","page":"API","title":"SurvivalAnalysis.Surv","text":"Surv(start, stop)\nSurv(time)\nSurv(time, status, type)\n\nThis is the entry point object into survival modelling.\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.SurvivalModel","page":"API","title":"SurvivalAnalysis.SurvivalModel","text":"SurvivalModel <: StatisticalModel\n\nAbstract type for all models implemented in, or extending, this package. Type 'inherits' from JuliaStats.StatisticalModel to enable formula fitting and predicting interface.\n\n\n\n\n\n","category":"type"},{"location":"api/#SurvivalAnalysis.SurvivalPrediction-Union{Tuple{}, Tuple{T}} where T<:Number","page":"API","title":"SurvivalAnalysis.SurvivalPrediction","text":"SurvivalPrediction(;\n    distr::Union{Nothing, Vector{<:Distribution}} = nothing,\n    lp::Union{Nothing, Vector{T}}  = nothing,\n    crank::Union{Nothing, Vector{T}} = nothing,\n    time::Union{Nothing, Vector{T}} = nothing,\n    fit_times::Union{Nothing, Vector{T}} = nothing,\n    survival_matrix::Union{Matrix{T}, Nothing} = nothing\n    ) where {T<:Number}\n\nSurvival models can make multiple types of predictions including:\n\ndistr - A survival time distribution (implemented with Distributions.jl)\nlp - A linear predictor (usually Xβ, i.e. covariates * fitted coefficients)\ncrank - A generic continuous relative risk ranking\ntime - A survival time\nsurvival_matrix - A matrix of predicted survival probabilities where rows are\n\nobservations and columns are fitted survival times corresponding to fit_times.\n\nThese predictions can only exist in a finite number of combinations so they are aggregated in types within this package (and automatically determined within this function):\n\nDeterministicSurvivalPrediction(lp, crank, time)\nDiscreteSurvivalPrediction(distr, lp, crank, time, survival_matrix)\nContinuousSurvivalPrediction(distr, lp, crank, time)\n\nAbsolutely no transformations take require assumptions take place within this function but it does transform survival_matrix to a Distributions.DiscreteNonParametric and vice versa.\n\nExamples\n\njulia> SurvivalPrediction(time = randn(5)); # DeterministicSurvivalPrediction\n\njulia> SurvivalPrediction(fit_times = randn(5), survival_matrix = randn((2, 5))); # DiscreteSurvivalPrediction\n\njulia> SurvivalPrediction(distr = fill(Exponential(), 2)); # ContinuousSurvivalPrediction\n\n\n\n\n\n","category":"method"},{"location":"api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SurvivalAnalysis]\nOrder   = [:function]","category":"page"},{"location":"api/#Distributions.scale-Tuple{StatsModels.TableStatisticalModel{var\"#s31\", var\"#s30\"} where {var\"#s31\"<:SurvivalAnalysis.ParametricSurvival, var\"#s30\"<:(AbstractMatrix{T} where T)}}","page":"API","title":"Distributions.scale","text":"scale(mm::StatsModels.TableStatisticalModel{<:ParametricSurvival, <:AbstractMatrix})\nscale(mm::ParametricSurvival)\n\nExtract estimated scale parameter (before transformation) for baseline distribution from fitted ParametricSurvival object.\n\n\n\n\n\n","category":"method"},{"location":"api/#RecipesBase.apply_recipe","page":"API","title":"RecipesBase.apply_recipe","text":"plot(npe::SurvivalEstimator, plot_confint::Bool = true; level = 0.95)\nplot(npe::StatsModels.TableStatisticalModel{SurvivalEstimator, Matrix{Float64}},\n    plot_confint::Bool = true; level = 0.95)\n\nRecipe for plotting fitted non-parametric estimators, npe. If plot_confint then confidence intervals also plotted at a level% confidence level.\n\nExamples\n\njulia> using Plots\n\njulia> data = DataFrame(t = randn(10), d = [trues(5)..., falses(5)...]);\n\njulia> plot(kaplan_meier(@formula(Srv(t, d) ~ 1), data));\n\njulia> plot(nelson_aalen(@formula(Srv(t, d) ~ 1), data).model);\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsAPI.coef-Tuple{StatsModels.TableStatisticalModel{var\"#s31\", var\"#s30\"} where {var\"#s31\"<:SurvivalAnalysis.ParametricSurvival, var\"#s30\"<:(AbstractMatrix{T} where T)}}","page":"API","title":"StatsAPI.coef","text":"coef(mm::StatsModels.TableStatisticalModel{<:ParametricSurvival, <:AbstractMatrix})\ncoef(mm::ParametricSurvival)\n\nExtract coefficients from fitted ParametricSurvival object.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.fit-Union{Tuple{T}, Tuple{Type{var\"#s24\"} where var\"#s24\"<:SurvivalAnalysis.ParametricSurvival, AbstractMatrix{var\"#s23\"} where var\"#s23\"<:Real, SurvivalAnalysis.RCSurv, Type{T}}} where T<:Distribution{Univariate, Continuous}","page":"API","title":"StatsAPI.fit","text":"fit(t::Type{<:ParametricSurvival}, X::AbstractMatrix{<:Real}, Y::RCSurv,\n    d::Type{T}; init::Number = 1) where {T <: ContinuousUnivariateDistribution}\n\nFit a [ParametricSurvival] survival model using matrix interface. It is recommended to use ph or aft directly instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{ParametricAFT, AbstractMatrix{var\"#s32\"} where var\"#s32\"<:Real}","page":"API","title":"StatsAPI.predict","text":"predict(fit::ParametricAFT, X::AbstractMatrix{<:Real})\npredict(fit::StatsModels.TableStatisticalModel{ParametricAFT, Matrix{Float64}},\n    data::DataFrames.DataFrame)\n\nMake predictions from a fitted ParametricAFT model. See How to fit and predict and examples below for predicting interfaces, we recommend using predict(fit, data::DataFrame).\n\nThree prediction types can be made from a fitted AFT model:\n\nlp - Xβ\ncrank - -Xβ\ndistr - F(t) = F₀(texp(Xβ))\n\nwhere β are estimated coefficients, X are covariates from the new data, and F₀ is the estimated baseline distribution CDF function. Predicted distributions are returned as ContinuousAFTDistribution <: Distributions.ContinuousUnivariateDistribution.\n\nNote❗ the AFT model assumes that a higher linear predictor means a lower risk of event and therefore a higher survival time, i.e., `βXᵢ > βXⱼ → hᵢ(t) < hⱼ(t) - hence crank = -lp.\n\nFuture updates will add transformation methods for more prediction types #12.\n\nFunction returns a SurvivalPrediction struct.\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = aft(@formula(Srv(Y, D) ~ X), data, Exponential);\n\njulia> predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));\n\n\n\n\n\n","category":"method"},{"location":"api/#StatsAPI.predict-Tuple{ParametricPH, AbstractMatrix{var\"#s32\"} where var\"#s32\"<:Real}","page":"API","title":"StatsAPI.predict","text":"predict(fit::ParametricPH, X::AbstractMatrix{<:Real})\npredict(fit::StatsModels.TableStatisticalModel{ParametricPH, Matrix{Float64}},\n    data::DataFrames.DataFrame)\n\nMake predictions from a fitted ParametricPH model. See How to fit and predict and examples below for predicting interfaces, we recommend using predict(fit, data::DataFrame).\n\nThree prediction types can be made from a fitted PH model:\n\nlp - Xβ\ncrank - Xβ\ndistr - F(t) = 1 - S₀(t)^exp(Xβ)\n\nwhere β are estimated coefficients, X are covariates from the new data, and S₀ is the estimated baseline distribution survival function. Predicted distributions are returned as ContinuousPHDistribution <: Distributions.ContinuousUnivariateDistribution.\n\nNote❗ the PH model assumes that a higher linear predictor means a higher risk of event and therefore a lower survival time, i.e., `βXᵢ > βXⱼ → hᵢ(t) > hⱼ(t) - hence crank = lp. This means when calculating concordance you must include rev = true.\n\nFuture updates will add transformation methods for more prediction types #12.\n\nFunction returns a SurvivalPrediction struct.\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = ph(@formula(Srv(Y, D) ~ X), data, Weibull);\n\njulia> predict(f, DataFrame(X = [2,9,1,1,exp(8),log(9),2^3,5^exp(2),1]));\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.Srv","page":"API","title":"SurvivalAnalysis.Srv","text":"Srv(T::Symbol, Δ::Symbol, type::Int = 1)\n\nCreate a SurvTerm object for internal use for fitting models. Arguments, T and Δ should be a reference to the name of the time and status variables in a DataFrame respectively. type should be 1 (or omitted) for right-censoring or -1 for left-censoring.\n\nExamples\n\njulia> @formula(Srv(t, d) ~ 1) # right-censoring\nFormulaTerm\nResponse:\n  (t,d)->Srv(t, d)\nPredictors:\n  1\n\njulia> @formula(Srv(t, d, -1) ~ X) # left-censoring\nFormulaTerm\nResponse:\n  (t,d)->Srv(t, d, -1)\nPredictors:\n  X(unknown)\n\n\n\n\n\n","category":"function"},{"location":"api/#SurvivalAnalysis.aft-Tuple","page":"API","title":"SurvivalAnalysis.aft","text":"aft(f::@formula, data::DataFrames.DataFrame, d::Type{T}; init::Number = 1)\naft(X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\nfit(ParametricAFT, X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\n\nFit a fully-parametric accelerated failure time (AFT) model with baseline distribution d. See How to fit and predict and examples below for fitting interfaces, we recommend using aft(::@formula...).\n\nFully-parametric AFT models are defined by\n\nh(t) = e^-Xβ h₀(t e^-Xβ)\n\nwhere β are coefficients to be estimated, X are covariates, and h₀ is the hazard function of an assumed baseline distribution, d. Available choices for distributions are:\n\nDistributions.Exponential\nDistributions.Weibull\n\nAFT models assumes that an increase in a covariate results in an acceleration of the event by a constant. This is best explained by example. The above formula can also be expressed as S(t) = S₀(exp(-η)t) then let ηᵢ = log(2) and ηⱼ = log(1) so ηᵢ  ηⱼ. Then Sᵢ(t) = S₀(0.5t) and Sⱼ(t) = S₀(t) and so for all t, Sᵢ(t) ≥ Sⱼ(t) as S is a decreasing function.\n\nFuture additions:\n\nMore baseline distributions #15\n\nFunction returns a ParametricAFT struct.\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = aft(@formula(Srv(Y, D) ~ X), data, Weibull)\nStatsModels.TableStatisticalModel{ParametricAFT{Weibull}, Matrix{Float64}}\n\n(Y,D;+) ~ 1 + X\n\nDistr:\nWeibull{Float64}(α=1.7439548025959823, θ=11.754846456706442)\n\nCoefficients:\n  (Scale)  (Intercept)            X\n 0.573409      2.46427  -0.00741527\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.baseline-Tuple{StatsModels.TableStatisticalModel{var\"#s31\", var\"#s30\"} where {var\"#s31\"<:SurvivalAnalysis.ParametricSurvival, var\"#s30\"<:(AbstractMatrix{T} where T)}}","page":"API","title":"SurvivalAnalysis.baseline","text":"baseline(mm::StatsModels.TableStatisticalModel{<:ParametricSurvival, <:AbstractMatrix})\nbaseline(mm::ParametricSurvival)\n\nExtract baseline distribution from fitted ParametricSurvival object.\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.concordance","page":"API","title":"SurvivalAnalysis.concordance","text":"concordance(\n    truth::OneSidedSurv, prediction::Vector{<:Number}, weights::Union{Symbol, ConcordanceWeights};\n    tied_preds=0.5, tied_times=0, cutoff=nothing, train::OneSidedSurv=nothing, rev=false\n)\ncindex(\n    truth::OneSidedSurv, prediction::Vector{<:Number}, weights::Union{Symbol, ConcordanceWeights};\n    tied_preds=0.5, tied_times=0, cutoff=nothing, train::OneSidedSurv=nothing, rev=false\n)\n\nGeneric function to call any concordance index method. Concordance is a measure of discrimination which evaluates if a prediction is concordant with the truth, i.e. let Tᵢ,Tⱼ be the true survival times, truth, for observations i and j and let  ϕᵢ, ϕⱼ be predictions, prediction, then these are concordant if ϕᵢ  ϕⱼ  Tᵢ  Tⱼ.\n\nIn survival analysis the generic C-index is defined as follows\n\nC = fracsum_ij W(tᵢ)I(tᵢ  tⱼ yᵢ  yⱼ tᵢ  τ)δᵢW(tᵢ)I(tᵢ  tⱼ tᵢ  τ)δᵢ\n\nwhere tᵢ,tⱼ are true survival times, yᵢ,yⱼ are predictions, τ is a cutoff time used to ensure stability even when censoring is high, δᵢ is the censoring indicator and W is a weighting function determined by weights as follows:\n\n:I or :Harrell - Harrell's C - W(tᵢ) = 1\n:G2 or :Uno - Uno's C - W(tᵢ) = 1G(tᵢ)\n:SG or :Schemper - Schemper's C - W(tᵢ) = S(tᵢ)G(tᵢ)\n:S or :Peto - Peto-Wilcoxon's C - W(tᵢ) = S(tᵢ)\n\nwhere S(tᵢ) and G(tᵢ) are respectively the Kaplan-Meier estimates of the survival and censoring distributions of the training data at time tᵢ. For any other combination of weights pass a ConcordanceWeights object to weights. Note❗ If training data is not provided to train then truth is used to estimate S and G but it is strongly recommended to provide the training data if possibe.\n\nWe also include an implementation of Gönen-Heller's C with weights = :GH or :Gonen. Note❗ this is actually a very different method from the others and calculates concordance for predictions from a Cox PH model only. We may move this to its own function in the future to avoid misuse.\n\nThere is open debate about how to handle ties when calculating the concordance. Ties can occur in predictions and in the observed survival times. The defaults here tied_preds=0.5 and tied_times=0 are set as these seem to be the most common but they can be changed. Note❗ If you pass a ConcordanceWeights object then the tied weights specified in this will take priority.\n\nNote❗ For predictions from PH models or any model where the prediction represents a relative risk then a higher value of ϕ implies a higher risk of event which will result in a lower survival time. In this case a prediction is concordant with the survival time if ϕᵢ  ϕⱼ  Tᵢ  Tⱼ. To do this within the function just set rev=true.\n\njulia> T = [1.0,0.1,pi,0.9,0.4,20,1,5,9,2.5];\n\njulia> ϕ = [0.1,0.2,0.1,0.9,0.25,exp(2),8,log(9),2,8];\n\njulia> Δ = [true,true,false,true,true,false,true,false,true,true];\n\njulia> Y = Surv(T, Δ, :r);\n\njulia> train = Surv([3,3,9,12,2,1,8,4,10,8], Δ, :r);\n\njulia> concordance(Y, ϕ, cutoff = threshold_risk(Y, 0.8)) # Harrell's C cutoff when 80% data is censored or dead\nSurvivalAnalysis.Concordance\n\nHarrell's C = 0.6153846153846154\n\nCutoff: T ≤ 9.0\nCounts:\n Pairs  Comparable  Concordant  Disconcordant\n    90          39          23             14\nWeights:\n IPCW  Tied preds  Tied times\n    1         0.5         0.0\nTies:\n Times  Preds  Both\n     1      2     0\nWeighted calculation:\n Numerator  Denominator         C\n      24.0         39.0  0.615385\n\njulia> concordance(Y, ϕ, :Uno, train=train) # Uno's C\nSurvivalAnalysis.Concordance\n\nUno's C = 0.6221374045801525\n\nCutoff: T ≤ 20.0\nCounts:\n Pairs  Comparable  Concordant  Disconcordant\n    90          39          23             14\nWeights:\n IPCW  Tied preds  Tied times\n 1/G²         0.5         0.0\nTies:\n Times  Preds  Both\n     1      2     0\nWeighted calculation:\n Numerator  Denominator         C\n   28.1728       45.284  0.622137\n\njulia> cindex(Y, ϕ, ConcordanceWeights(5, -3, 0.5, 0.5, \"Silly Weights\"); train=train) # Custom weights\nSurvivalAnalysis.Concordance\n\nSilly Weights C = 0.6070334788405888\n\nCutoff: T ≤ 20.0\nCounts:\n Pairs  Comparable  Concordant  Disconcordant\n    90          40          23             14\nWeights:\n  IPCW  Tied preds  Tied times\n S⁵/G³         0.5         0.5\nTies:\n Times  Preds  Both\n     1      2     0\nWeighted calculation:\n Numerator  Denominator         C\n   25.6265       42.216  0.607033\n\n\n\n\n\n","category":"function"},{"location":"api/#SurvivalAnalysis.cum_hazard-Tuple{UnivariateDistribution{S} where S<:ValueSupport, Real}","page":"API","title":"SurvivalAnalysis.cum_hazard","text":"cum_hazard(d::UnivariateDistribution, x::Real)\nHₜ(d::UnivariateDistribution, x::Real)\n\nCompute the cumulative hazard function of distribution d at point x.\n\nThe cumulative hazard function for random variable t is defined as\n\nH_t(x) = int^x_0 h_t(u) du = -log(S_t(x))\n\nwhere hₜ is the hazard function of t and Sₜ is the survival function of t.\n\nExamples\n\njulia> using Distributions\n\njulia> cum_hazard(Binomial(5, 0.5), 3)\n1.6739764335716711\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.hazard-Tuple{UnivariateDistribution{S} where S<:ValueSupport, Real}","page":"API","title":"SurvivalAnalysis.hazard","text":"hazard(d::UnivariateDistribution, x::Real)\nhₜ(d::UnivariateDistribution, x::Real)\n\nCompute the hazard function of distribution d at point x.\n\nThe hazard function for random variable t is defined as\n\nh_t(x) = fracf_t(x)S_t(x)\n\nwhere fₜ is the pdf of t and Sₜ is the survival function of t.\n\nExamples\n\njulia> using Distributions\n\njulia> hazard(Binomial(5, 0.5), 3)\n1.6666666666666679\n\n\n\n\n\n","category":"method"},{"location":"api/#SurvivalAnalysis.ph-Tuple","page":"API","title":"SurvivalAnalysis.ph","text":"ph(f::@formula, data::DataFrames.DataFrame, d::Type{T}; init::Number = 1)\nph(X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\nfit(ParametricPH, X::AbstractMatrix{<:Real}, Y::RCSurv, d::Type{T}; init::Number = 1)\n\nFit a fully-parametric proportional hazards (PH) model with baseline distribution d. See How to fit and predict and examples below for fitting interfaces, we recommend using ph(::@formula...).\n\nFully-parametric PH models are defined by\n\nh(t) = h₀(t)exp(Xβ)\n\nwhere β are coefficients to be estimated, X are covariates, and h₀ is the hazard function of an assumed baseline distribution, d. Available choices for distributions are:\n\nDistributions.Exponential\nDistributions.Weibull\n\nNo other distributions have the PH assumption, which assumes that the risk of an event taking place is constant over time.\n\nFuture additions:\n\nMethods for testing if the assumption is valid for your data #11.\nMethods to calculate hazards ratios and add to show #40.\n\nFunction returns a ParametricPH struct.\n\njulia> Y = [1,1,4,6,8,4,9,4,5,10];\n\njulia> D = [true, false, false, false, true, false, false, true, true, false];\n\njulia> X = [1,9,3,4,20,-4,pi,exp(5),log(8),0];\n\njulia> data = DataFrame(Y = Y, D = D, X = X);\n\njulia> f = ph(@formula(Srv(Y, D) ~ X), data, Exponential)\nStatsModels.TableStatisticalModel{ParametricPH{Exponential}, Matrix{Float64}}\n\n(Y,D;+) ~ 1 + X\n\nDistr:\nExponential{Float64}(θ=17.121272620254064)\n\nCoefficients:\n (Scale)  (Intercept)          X\n     1.0     -2.84032  0.0101247\n\n\n\n\n\n","category":"method"},{"location":"api/#Macros-and-Constants","page":"API","title":"Macros and Constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SurvivalAnalysis]\nOrder   = [:macro, :constant]","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"DocTestSetup = quote\n    using DataFrames, Distributions, SurvivalAnalysis, Random\nend","category":"page"},{"location":"examples/#How-to-fit-and-predict","page":"Examples","title":"How to fit and predict","text":"","category":"section"},{"location":"examples/#Fitting","page":"Examples","title":"Fitting","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Models can be fit in one of four ways but we only recommend the first.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> data = DataFrame(Y = [1,1,4,6,8,4,9,4,5,10], D = [true, false, false, false, true, false, false, true, true, false])\n10×2 DataFrame\n Row │ Y      D\n     │ Int64  Bool\n─────┼──────────────\n   1 │     1   true\n   2 │     1  false\n   3 │     4  false\n   4 │     6  false\n   5 │     8   true\n   6 │     4  false\n   7 │     9  false\n   8 │     4   true\n   9 │     5   true\n  10 │    10  false","category":"page"},{"location":"examples/#.-Function-Formula","page":"Examples","title":"1. Function + Formula","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f = kaplan_meier(@formula(Srv(Y, D) ~ 1), data)\nStatsModels.TableStatisticalModel{KaplanMeier, Matrix{Float64}}\n\n(Y,D;+) ~ 1\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"examples/#.-fit-Formula","page":"Examples","title":"2. fit + Formula","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia>  f = fit(KaplanMeier, @formula(Srv(Y, D) ~ 1), data)\nStatsModels.TableStatisticalModel{KaplanMeier, Matrix{Float64}}\n\n(Y,D;+) ~ 1\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"examples/#.-Function-Data","page":"Examples","title":"3. Function + Data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f = kaplan_meier(hcat(ones(10), 1:10), Surv(data.Y, data.D, :r))\nKaplanMeier\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"examples/#.-fit-Data","page":"Examples","title":"4. fit + Data","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f = fit(KaplanMeier, hcat(ones(10), 1:10), Surv(data.Y, data.D, :right))\nKaplanMeier\n\nCoefficients:\n  n  ncens  nevents\n 10      6        4","category":"page"},{"location":"examples/#Predicting","page":"Examples","title":"Predicting","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"If fitting method (1) or (2) are selected then new data must be given as a DataFrame, otherwise a Matrix is sufficient. We strongly recommend the formula method as this ensures the same covariates and predictors are used in fitting and predicting.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"julia> f = kaplan_meier(@formula(Srv(Y, D) ~ 1), data);\n\njulia> predict(f, DataFrame(Y = randn(10), D = trues(10)));","category":"page"},{"location":"#SurvivalAnalysis.jl-Manual","page":"Home","title":"SurvivalAnalysis.jl Manual","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Survival analysis in Julia.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the latest version from JuliaRegistries with","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"SurvivalAnalysis\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or install the latest stable version from GitHub with","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(url=\"https://github.com/RaphaelS1/SurvivalAnalysis.jl.git\")","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Parametric models\nSemi-parametric models\nNonparametric estimators","category":"page"},{"location":"#Upcoming-features","page":"Home","title":"Upcoming features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Bayesian methods\nSurvival metrics (discrimination, calibration, scoring rules)","category":"page"}]
}
